<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅秋</title>
  
  <subtitle>让现在的自己活的轻松，就是让未来的自己活的悲惨。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangyi5628.github.io/"/>
  <updated>2017-11-24T13:45:51.000Z</updated>
  <id>http://zhangyi5628.github.io/</id>
  
  <author>
    <name>浅秋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>touch-action控制触摸操作</title>
    <link href="http://zhangyi5628.github.io/2017/11/24/touch-action%E6%8E%A7%E5%88%B6%E8%A7%A6%E6%91%B8%E6%93%8D%E4%BD%9C/"/>
    <id>http://zhangyi5628.github.io/2017/11/24/touch-action控制触摸操作/</id>
    <published>2017-11-24T13:45:31.000Z</published>
    <updated>2017-11-24T13:45:51.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="touch-action"><a href="#touch-action" class="headerlink" title="touch-action"></a>touch-action</h4><p>CSS属性 touch-action 用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作，用于控制元素的默认触摸行为。  </p><p>常用的 touch-action 值：<br>|  触摸操作参数 | 描述<br>| ——– | ————- |<br>| touch-action: none | 浏览器将不处理触摸交互。 |<br>| touch-action: pinch-zoom | 像 <code>touch-action: none</code> 一样停用所有浏览器交互（ <code>pinch-zoom</code> 除外，该交互仍由浏览器处理。 |<br>| touch-action: pan-y pinch-zoom | touch-action: pan-y pinch-zoom |<br>| touch-action: manipulation |  停用点按两次手势，可避免浏览器的任何点按延迟。 将滚动和双指张合缩放交由浏览器处理。 |</p><p>touch-action: none 来防止浏览器在用户触摸时执行任何操作，从而拦截所有触摸事件。<br>使用 touch-action: none 的影响颇为巨大，因为它会阻止所有默认的浏览器行为。 在许多情况下，采用下面其中一个解决方案是更好的选择。</p><p>touch-action 可停用浏览器实现的手势。例如，IE10 以上版本支持点按两次执行缩放手势。 将 touch-action 设置为 manipulation 可以阻止点按两次的默认行为。</p><p>这样您就可以自行实现点按两次手势。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;touch-action&quot;&gt;&lt;a href=&quot;#touch-action&quot; class=&quot;headerlink&quot; title=&quot;touch-action&quot;&gt;&lt;/a&gt;touch-action&lt;/h4&gt;&lt;p&gt;CSS属性 touch-action 用于指定某个给定的区域
      
    
    </summary>
    
    
      <category term="HTML5" scheme="http://zhangyi5628.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>iOS Safari 真机调试网页</title>
    <link href="http://zhangyi5628.github.io/2017/11/24/iOS%20Safari%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E7%BD%91%E9%A1%B5/"/>
    <id>http://zhangyi5628.github.io/2017/11/24/iOS Safari真机调试网页/</id>
    <published>2017-11-24T13:29:15.000Z</published>
    <updated>2017-11-24T13:31:27.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>平时开发移动端页面时，我们一般也都先选择再chrome上模拟手机浏览器来调试，这样很方便。但是有些时候电脑上运行的好好的，在手机上还是有出现莫名其妙的问题，让人捉不到头脑，这个时候如果能在真机上运行，在电脑上的浏览器中调试就再好不过了。  </p><p>对于iPhone来说，iOS5.0开始，可以通过Safari的Web Inspector工具连接设备对应用进行调试。</p><h4 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h4><h5 id="一、开启iOS设备的调试功能"><a href="#一、开启iOS设备的调试功能" class="headerlink" title="一、开启iOS设备的调试功能"></a>一、开启iOS设备的调试功能</h5><p>打开“设置 - Safari - 高级”页面，开启“Web检查器”  </p><p><img src="http://owtrjd7fu.bkt.clouddn.com/Safari%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95-iOS%E5%BC%80%E5%90%AF%E8%B0%83%E8%AF%95.jpeg" width="330" alt="图片名称" align="center">  </p><p>其他手机上安装的需求调试的应用，打开对应的WebView页面或者是浏览器，并把手机连接到电脑。</p><h5 id="二、开启Safari的调试功能"><a href="#二、开启Safari的调试功能" class="headerlink" title="二、开启Safari的调试功能"></a>二、开启Safari的调试功能</h5><p>运行Safari,点击Safari的“偏好设置”，切换到“高级”  </p><p><img src="http://owtrjd7fu.bkt.clouddn.com/Safari%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95-%E6%89%93%E5%BC%80%E5%BC%80%E5%8F%91%E8%8F%9C%E5%8D%95.jpg" width="620" alt="开启Safari的调试功能" align="center">  </p><p>勾选“在菜单中显示‘开发’菜单”，关闭偏好设置，这是在Safari的工具栏上就能看到“开发”菜单。</p><h5 id="三、连接真机"><a href="#三、连接真机" class="headerlink" title="三、连接真机"></a>三、连接真机</h5><p>点击“开发”这时能看到连接的设备，hover到对应的设备上，选择连接要调试的页面  </p><p><img src="http://owtrjd7fu.bkt.clouddn.com/Safari%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95-%E8%BF%9E%E6%8E%A5%E8%B0%83%E8%AF%95.jpg" width="620" alt="连接调试" align="center">  </p><h4 id="四、调试"><a href="#四、调试" class="headerlink" title="四、调试"></a>四、调试</h4><p>打开Web Inspector界面后，即可调试JavaScript、检查HTML页面DOM结构、实时同步更新元素CSS样式、加断点调试等操作  </p><p><img src="http://owtrjd7fu.bkt.clouddn.com/Safari%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95-%E8%B0%83%E8%AF%95.jpg" width="620" alt="调试" align="center"></p><p>很 easy!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;平时开发移动端页面时，我们一般也都先选择再chrome上模拟手机浏览器来调试，这样很方便。但是有些时候电脑上运行的好好的，在手机上还是有出现
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webkit-overflow-scrolling 让滚动条更流畅</title>
    <link href="http://zhangyi5628.github.io/2017/10/10/webkit-overflow-scrolling-%E8%AE%A9%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%9B%B4%E6%B5%81%E7%95%85/"/>
    <id>http://zhangyi5628.github.io/2017/10/10/webkit-overflow-scrolling-让滚动条更流畅/</id>
    <published>2017-10-10T03:14:24.000Z</published>
    <updated>2017-12-02T03:15:22.352Z</updated>
    
    <content type="html"><![CDATA[<p>Html5页面一般滚动效果和iOS原生的效果比都会比较生涩，没有回弹效果。<br>如果我们想要iOS小的滚动效果，一般有两种方法，一是使用iscroll来模拟，但是这样代价太大。还有一种方法就比较简单，可以加上iOS独有的属性：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-overflow-scrolling</span>: <span class="selector-tag">touch</span>;</span><br></pre></td></tr></table></figure></p><p>详见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/-webkit-overflow-scrolling" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/-webkit-overflow-scrolling</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Html5页面一般滚动效果和iOS原生的效果比都会比较生涩，没有回弹效果。&lt;br&gt;如果我们想要iOS小的滚动效果，一般有两种方法，一是使用iscroll来模拟，但是这样代价太大。还有一种方法就比较简单，可以加上iOS独有的属性：&lt;br&gt;&lt;figure class=&quot;high
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack react react-router-v4 code-splitting</title>
    <link href="http://zhangyi5628.github.io/2017/09/20/webpack-react-react-router-v4-code-splitting/"/>
    <id>http://zhangyi5628.github.io/2017/09/20/webpack-react-react-router-v4-code-splitting/</id>
    <published>2017-09-20T03:04:24.000Z</published>
    <updated>2017-12-02T03:07:13.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>最近准备做一个公司项目，在搭建框架时为了技术选型有研究了下React Router v4，看了网上对v4版本的评价可谓是哀鸿一片啊。React Router v3的设计思想更容易前端工程师接受类似于配置文件，v3的配置是将path映射为渲染模块，而去这种映射关系是静态的。而v4时动态映射，v4中Route也是一个React组件，可以和其他组件一样被渲染，在运行时决定某个Route渲染还是不渲染。v3到v4的升级更像时一个全新的库，API发生了巨大变化。于是就想这选用v3版本搭一套，有时间在用v4整一套。等我项目框架快要搭好的时候，结果项目评审没过，产品要回去修改在重新评审，哇哈哈！那我就去研究研究React Router v4吧！使用v4的过程中觉得其他地方都还好，查查API都能解决，唯独麻烦的是Code-splitting这块变化比较大。webpack的文档中没有特定针对react-router下code-splitting的文档。react-router v4下的 code-splitting文档写的使用bundle-loader的方法，也不够优雅。于是乎研究下，写下这篇文章以后自己回顾时方便也希望能帮助到其他人。</p><h3 id="Code-splitting"><a href="#Code-splitting" class="headerlink" title="Code-splitting"></a>Code-splitting</h3><p>对于一些大型的单页应用，代码量大，如果我们还是把所有js文件打包在一个js文件中，js文件很大还不能并行加载，就会导致用户首屏页面加载很慢。于是乎把公用的代码抽出来作为一个js文件，不同页面或者不同业务下的页面分成多个代码块（chunk），用户只需要下载当前页面的js，进入其他页面再去加载对应的js代码，这样就能很好的提升用户体验和不必要的流量损失。这就需要用到代码分割（code-splitting）<br>webpack文档中提供了三种分割代码的方法：<br>1、利用 webpack 中的 entry 配置项来进行手动分割<br>2、利用 CommonsChunkPlugin 插件来提取重复 chunk<br>3、动态引入（Dynamic Imports）<br>这里只讲第三种方法。</p><h3 id="React-Router-v3的按需加载"><a href="#React-Router-v3的按需加载" class="headerlink" title="React Router v3的按需加载"></a>React Router v3的按需加载</h3><p>在v4之前的版本中，想要实现按需加载Component，需要使用getCompoent方法，但是在v4中getComponent方法已经被移除。先来介绍下v3下按需加载的方法</p><h4 id="1、使用require-ensure"><a href="#1、使用require-ensure" class="headerlink" title="1、使用require.ensure"></a>1、使用require.ensure</h4><p>代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置route</span></span><br><span class="line">&lt;Route path=<span class="string">"home"</span> getComponent=&#123;(location, cb) =&gt; &#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'../Component/home'</span>).default)</span><br><span class="line">    &#125;,<span class="string">'home'</span>)</span><br><span class="line">&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>这种方法比较老，貌似webpack 3之后版本不支持（待验证）</p><h4 id="2、使用import-webpackChunkName"><a href="#2、使用import-webpackChunkName" class="headerlink" title="2、使用import+webpackChunkName"></a>2、使用import+webpackChunkName</h4><p>这种方法需要使用ES6和ES7语法，但是写起来很简便<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/home"</span> getComponent=&#123;<span class="keyword">async</span> (nextState, cb) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> Home = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'../containers/Home'</span>);</span><br><span class="line">    cb(<span class="literal">null</span>, Home.default)</span><br><span class="line">&#125;&#125;/&gt;</span><br><span class="line">&lt;Route path=<span class="string">"/list"</span> getComponent=&#123;<span class="keyword">async</span> (nextState, cb) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> List = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "list" */</span> <span class="string">'../containers/List'</span>);</span><br><span class="line">    cb(<span class="literal">null</span>, List.default)</span><br><span class="line">&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="React-Router-v4下的按需加载"><a href="#React-Router-v4下的按需加载" class="headerlink" title="React Router v4下的按需加载"></a>React Router v4下的按需加载</h3><h4 id="使用-bundle-loader-的方案"><a href="#使用-bundle-loader-的方案" class="headerlink" title="使用 bundle-loader 的方案"></a>使用 bundle-loader 的方案</h4><p>在 React Router v4 官方给出的<a href="https://reacttraining.com/react-router/web/guides/code-splitting" target="_blank" rel="noopener">文档</a>中，使用了名为 bundle-loader 的工具来实现这一功能。<br>其主要实现思路为创建一个名为 <bundle> 的组件，当应用匹配到了对应的路径时，该组件会动态地引入所需模块并将自身渲染出来。<br>示例代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> loadSomething <span class="keyword">from</span> <span class="string">'bundle-loader?lazy!./Something'</span></span><br><span class="line">&lt;Bundle load=&#123;loadSomething&#125;&gt;</span><br><span class="line">  &#123;(mod) =&gt; (</span><br><span class="line">    <span class="comment">// do something w/ the module</span></span><br><span class="line">  )&#125;</span><br><span class="line">&lt;<span class="regexp">/Bundle&gt;</span></span><br></pre></td></tr></table></figure></bundle></p><p>这种方式看着就不太爽，代码太丑了。而去在几个月前我试过这种方式，貌似有些问题一直没成功。所以我就直接找其他方法了。</p><h4 id="使用import"><a href="#使用import" class="headerlink" title="使用import()"></a>使用import()</h4><p>一个常规的 React Router 项目结构如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./containers/Home'</span></span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./containers/List'</span></span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'./containers/Demo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Routes</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/list"</span> component=&#123;List&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/Demo"</span> component=&#123;Demo&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>首先根据我们的 route 引入相应的组件，然后将其用于定义相应的 <route>。<br>但是，不管匹配到了哪一个 route，我们这里都一次性地引入所有的组件。而我们想要的效果是当匹配了一个 route，则只引入与其对应的组件，这就需要实现代码分割了。</route></p><h5 id="创建一个异步组件（Async-Component）"><a href="#创建一个异步组件（Async-Component）" class="headerlink" title="创建一个异步组件（Async Component）"></a>创建一个异步组件（Async Component）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncComponent</span>(<span class="params">importComponent</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AsyncComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">            <span class="keyword">super</span>(props);</span><br><span class="line">            <span class="keyword">this</span>.state = &#123;</span><br><span class="line">                component: <span class="literal">null</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; <span class="attr">default</span>: component &#125; = <span class="keyword">await</span> importComponent();</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                component: component</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> C = <span class="keyword">this</span>.state.component;</span><br><span class="line">            <span class="keyword">return</span> C</span><br><span class="line">                ? <span class="xml"><span class="tag">&lt;<span class="name">C</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">                : null;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    return AsyncComponent;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>asyncComponent 接收一个 importComponent 函数作为参数，importComponent() 在被调用时会动态引入给定的组件。<br>在 componentDidMount()中，调用传入的 importComponent()，并将动态引入的组件保存在 state 中。</p><h5 id="使用异步组件（Async-Component"><a href="#使用异步组件（Async-Component" class="headerlink" title="使用异步组件（Async Component"></a>使用异步组件（Async Component</h5><p>使用 asyncComponent 方法来动态引入组件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'../containers/Home'</span>));</span><br></pre></td></tr></table></figure></p><p>此处import()返回的是一个 Promise，这是一种动态引入模块的方法，即上文 webpack 文档中提到的第三种方法。  </p><p>注意这里并没有进行组件的引入，而是传给了 asyncComponent 一个函数，它将在 AsyncHome 组件被创建时进行动态引入。同时，这种传入一个函数作为参数，而非直接传入一个字符串的写法能够让 webpack 意识到此处需要进行代码分割。</p><p>routes完整代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Switch, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> asyncComponent <span class="keyword">from</span> <span class="string">'./asyncComponent'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'../containers/Home'</span>));</span><br><span class="line"><span class="keyword">const</span> List = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "list" */</span> <span class="string">'../containers/List'</span>));</span><br><span class="line"><span class="keyword">const</span> Demo = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "list" */</span> <span class="string">'../containers/Demo'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Routes</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/list"</span> component=&#123;List&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/Demo"</span> component=&#123;Demo&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h3&gt;&lt;p&gt;最近准备做一个公司项目，在搭建框架时为了技术选型有研究了下React Router v4，看了网上对v4版本的评价可谓是哀鸿
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端HTML5 input常见问题</title>
    <link href="http://zhangyi5628.github.io/2016/11/22/%E7%A7%BB%E5%8A%A8%E7%AB%AFHTML5-input%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://zhangyi5628.github.io/2016/11/22/移动端HTML5-input常见问题/</id>
    <published>2016-11-22T13:41:38.000Z</published>
    <updated>2017-11-24T13:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-去掉input-在iOS中的默认圆角和内阴影"><a href="#1-去掉input-在iOS中的默认圆角和内阴影" class="headerlink" title="1. 去掉input 在iOS中的默认圆角和内阴影"></a>1. 去掉input 在iOS中的默认圆角和内阴影</h4><p>iOS下 input会有自带的圆角和内阴影，去掉方法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>&#123;</span><br><span class="line"><span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-焦点在-input-时，placeholder-没有隐藏"><a href="#2-焦点在-input-时，placeholder-没有隐藏" class="headerlink" title="2. 焦点在 input 时，placeholder 没有隐藏"></a>2. 焦点在 input 时，placeholder 没有隐藏</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span><span class="selector-pseudo">::-webkit-input-placeholder</span>&#123;</span><br><span class="line"><span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-input-输入框调出数字键盘"><a href="#3-input-输入框调出数字键盘" class="headerlink" title="3. input 输入框调出数字键盘"></a>3. input 输入框调出数字键盘</h4><p>单独使用type=”number”时，iOS调起的并不是九宫格样式的数字键盘，如果需要调起九宫格的数字键盘需要加上 pattern=”[0-9]*” 属性<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数字键盘 带有符号，非九宫格样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 九宫格数字键盘 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">pattern</span>=<span class="string">"[0-9]*"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 电话号码键盘 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="4-搜索时，键盘的回车按钮文字设定为“搜索”"><a href="#4-搜索时，键盘的回车按钮文字设定为“搜索”" class="headerlink" title="4. 搜索时，键盘的回车按钮文字设定为“搜索”"></a>4. 搜索时，键盘的回车按钮文字设定为“搜索”</h4><p>解决： input 使用 type=”search”，放在 form 表单内。两者结合就能使输入法中的回车按钮文字变为“搜索”<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-去掉input-在iOS中的默认圆角和内阴影&quot;&gt;&lt;a href=&quot;#1-去掉input-在iOS中的默认圆角和内阴影&quot; class=&quot;headerlink&quot; title=&quot;1. 去掉input 在iOS中的默认圆角和内阴影&quot;&gt;&lt;/a&gt;1. 去掉input 在i
      
    
    </summary>
    
    
      <category term="HTML5" scheme="http://zhangyi5628.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>Safari active伪类失效问题</title>
    <link href="http://zhangyi5628.github.io/2016/10/28/active%E4%BC%AA%E7%B1%BB%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>http://zhangyi5628.github.io/2016/10/28/active伪类失效问题/</id>
    <published>2016-10-28T01:13:55.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做移动端项目时，发现通过伪类:active给按钮添加点击效果时，iOS下无效，PC下是正常的。</p><h3 id="1-失效原因"><a href="#1-失效原因" class="headerlink" title="1.失效原因"></a>1.失效原因</h3><p>我们可以从Safari Developer Library中找到答案,描述如下:</p><blockquote><p>“You can also use the -webkit-tap-highlight-color CSS property in combination with setting a touch event to configure buttons to behave similar to the desktop. On iOS, mouse events are sent so quickly that the down or active state is never received. Therefore, the :active pseudo state is triggered only when there is a touch event set on the HTML element—for example, when ontouchstart is set on the element as follows:”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;action&quot; ontouchstart=&quot;&quot;  </span><br><span class="line">style=&quot;-webkit-tap-highlight-color: rgba(0,0,0,0);&quot;&gt;  </span><br><span class="line">    Testing Touch on iOS</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><p>“Now when the button is tapped and held on iOS, the button changes to the specified color without the surrounding transparent gray color appearing.”</p></blockquote><p>其中的描述,在iOS上,鼠标事件是太快了,按钮及active状态无法触发,因此,:active状态只能在设置了touch 事件的元素上触发,具体可详见上文中标红色部分.</p><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><h4 id="1-像上面那样"><a href="#1-像上面那样" class="headerlink" title="1) 像上面那样:"></a>1) 像上面那样:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ontouchstart</span>=<span class="string">""</span> &gt;</span>Testing Touch on iOS<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-另一种就是在docuemnt上绑定touchstart事件"><a href="#2-另一种就是在docuemnt上绑定touchstart事件" class="headerlink" title="2)另一种就是在docuemnt上绑定touchstart事件"></a>2)另一种就是在docuemnt上绑定touchstart事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;touchstart&quot;, function() &#123;</span><br><span class="line">   // do nothing</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在做移动端项目时，发现通过伪类:active给按钮添加点击效果时，iOS下无效，PC下是正常的。&lt;/p&gt;
&lt;h3 id=&quot;1-失效原因&quot;&gt;&lt;a href=&quot;#1-失效原因&quot; class=&quot;headerlink&quot; title=&quot;1.失效原因&quot;&gt;&lt;/a&gt;1.失效原因&lt;/h3
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>修复打开弹窗后触摸屏幕有覆盖高亮颜色问题（-webkit-tap-highlight-color）</title>
    <link href="http://zhangyi5628.github.io/2016/10/19/%E4%BF%AE%E5%A4%8D%E6%89%93%E5%BC%80%E5%BC%B9%E7%AA%97%E5%90%8E%E8%A7%A6%E6%91%B8%E5%B1%8F%E5%B9%95%E6%9C%89%E8%A6%86%E7%9B%96%E9%AB%98%E4%BA%AE%E9%A2%9C%E8%89%B2%E9%97%AE%E9%A2%98%EF%BC%88-webkit-tap-highlight-color%EF%BC%89/"/>
    <id>http://zhangyi5628.github.io/2016/10/19/修复打开弹窗后触摸屏幕有覆盖高亮颜色问题（-webkit-tap-highlight-color）/</id>
    <published>2016-10-19T01:08:49.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近在做Html5弹窗组件（Modal）的时候，发现在弹窗打开后触摸屏幕时全屏会被覆盖半透明的灰色背景，着实让我摸不着头脑，后来查看Antd Design Mobile组件库源码时候发现了解决方法。原来是需要设置-webkit-tap-highlight-color 属性</p><h3 id="webkit-tap-highlight-color"><a href="#webkit-tap-highlight-color" class="headerlink" title="-webkit-tap-highlight-color"></a>-webkit-tap-highlight-color</h3><p>这个属性只用于iOS (iPhone和iPad)。当你点击一个链接或者通过Javascript定义的可点击元素的时候，它就会出现一个半透明的灰色背景。要重设这个表现，你可以设置-webkit-tap-highlight-color为任何颜色。<br>想要禁用这个高亮，设置颜色的alpha值为0即可<br>大部分android手机也是支持的，只是显示效果有所不同。</p><h4 id="全局禁用"><a href="#全局禁用" class="headerlink" title="全局禁用"></a>全局禁用</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*,</span><br><span class="line">*<span class="selector-pseudo">:before</span>,</span><br><span class="line">*<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他鲜为人知的属性"><a href="#其他鲜为人知的属性" class="headerlink" title="其他鲜为人知的属性"></a>其他鲜为人知的属性</h3><h4 id="（一）css3中-webkit-text-size-adjust详解："><a href="#（一）css3中-webkit-text-size-adjust详解：" class="headerlink" title="（一）css3中-webkit-text-size-adjust详解："></a>（一）css3中-webkit-text-size-adjust详解：</h4><p>1、当样式表里font-size&lt;12px时，中文版chrome浏览器里字体显示仍为12px，这时可以用  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;<span class="attribute">-webkit-text-size-adjust</span>:none;&#125;</span><br></pre></td></tr></table></figure><p>2、-webkit-text-size-adjust放在body上会导致页面缩放失效<br>3、body会继承定义在html的样式<br>4、用-webkit-text-size-adjust不要定义成可继承的或全局的  </p><h4 id="（二）webkit-appearance"><a href="#（二）webkit-appearance" class="headerlink" title="（二）webkit-appearance"></a>（二）webkit-appearance</h4><p>-webkit-appearance: none;<br>//消除输入框和按钮的原生外观，在iOS上加上这个属性才能给按钮和输入框自定义样式。<br>注意：不同type的input使用这个属性之后表现不一。text、button无样式，radio、checkbox直接消失  </p><h4 id="（三）-webkit-user-select"><a href="#（三）-webkit-user-select" class="headerlink" title="（三）-webkit-user-select"></a>（三）-webkit-user-select</h4><p>-webkit-user-select: none;<br>// 禁止页面文字选择 ，此属性不继承，一般加在body上规定整个body的文字都不会自动调整</p><h4 id="（四）-webkit-touch-callout"><a href="#（四）-webkit-touch-callout" class="headerlink" title="（四）-webkit-touch-callout"></a>（四）-webkit-touch-callout</h4><p>-webkit-touch-callout:none;<br>// 禁用长按页面时的弹出菜单(iOS下有效) ,img和a标签都要加</p><h4 id="（五）-webkit-appearance"><a href="#（五）-webkit-appearance" class="headerlink" title="（五）-webkit-appearance"></a>（五）-webkit-appearance</h4><p>-webkit-appearance:button;<br>使元素看上去像一个按钮</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;最近在做Html5弹窗组件（Modal）的时候，发现在弹窗打开后触摸屏幕时全屏会被覆盖半透明的灰色背景，着实让我摸不着头脑，后来查看Antd
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个前端的自我修养</title>
    <link href="http://zhangyi5628.github.io/2016/08/30/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    <id>http://zhangyi5628.github.io/2016/08/30/一个前端的自我修养/</id>
    <published>2016-08-30T05:45:38.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自：寒泉 [<a href="http://kb.cnblogs.com/page/545784/" target="_blank" rel="noopener">一个前端的自我修养</a>]<br>　　今天给大家分享的主题是前端的自我成长，这是一个关于成长的话题。<br>　　很多人都有这样的感觉：听了很多技术圈子的分享，有的有深度，有的循循善诱，深入浅出，但是呢，几年下来，到底哪些用上了，哪些对自己真的有帮助了?反而有些模糊。<br>　　2015 年我在不同的场合分享了很多内容：有移动端的性能、有适配、有 Web vs Native，也有 hybrid，但是其实我一直比较担心，真正有深度的内容，其实面向的是比较小众的群体，比如说 Hybrid，其实它在大部分公司里面，是只能用现成的。<br>　　所以我这一次尝试分享一个我认为可以帮助到所有前端的话题，关于前端的成长，如果说这个分享的内容，听众里面有那么几十个人拿到 BAT 的 offer，或者升职加薪，那么我觉得我就认为我取得了成功。<br>　　前端其实是个特别苦逼的职业，因为前端技术一直革命的特别快，新技术、新技巧在不断地被发明出来。之前我有一个朋友，他讲说他对自己的认知是了解前端、熟悉前端、精通前端、熟悉前端、不懂前端。为什么呢，他说当他觉得自己对前端所有的东西觉得无所不知，无所不能的时候，忽然看到了一段代码，他完全无法理解，于是整个世界就崩塌了，从此再也不敢说自己会前端。<br>　　我就跟他说，这里，缺少的是一种正确的方法，你觉得无所不知、无所不能的标准是什么，是工作中很久没遇到解决不了的问题么？他说还真是这样。我就又问他，那你系统学过前端么？他想了想，还真没学过，大学里不开这个课。的确如此，到目前为止，还没有任何一个大学会教前端，倒是有些培训班，会讲网页开发三剑客。<br>　　我这里讲的内容，希望带给大家的，就是该如何学习前端，实现自身成长。<br><img src="http://gw.alicdn.com/bao/uploaded/TB1CPRlMXXXXXafaXXXXXXXXXXX-826-222.png" alt=""><br>　　关于成长，首先我得发一个免责声明，不是我对我讲的内容没有信心，而是成长是自己的事，英文有句话，在外企工作的人会经常听到，叫做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You are the owner of your career.</span><br></pre></td></tr></table></figure></p><p>　　你是你职业发展的责任人。这句话潜台词是，你（不是你老板，也不是你爸妈，也不是你女朋友）是你职业发展的责任人。<br>　　这句话我在我职业生涯的起点听说，一直指导我的职业发展，甚至在我带团队，培养团队的时候，也是中心的指导思想，之前我带的团队的同学，他们有不少人也在带团队，其实他们也在实践这句话，所以我这里，也把这句话、把这个道理分享给给大家。<br><img src="http://gw.alicdn.com/bao/uploaded/TB1L5FfMXXXXXXaapXXXXXXXXXX-1501-789.png" alt=""><br>　　我们讲前端成长，<strong>我认为，主要在两个方面，一部分是“能力”，一部分是“知识”</strong>。我个人的观点，能力占百分之八十，知识占百分之二十。<br>　　从这个图上，大家可以看到，其实我们认为变化快的东西，最新出来的 Angular、React、ES2015，其实都在知识里面，知识又分成两部分，一部分我把它叫做标准，它是相对而言比较稳定的，很少会出现一个标准被推翻的事情。另一部分则是技术，像是 jQuery、React 这些框架啦，像是 MVC、FLUX 这些架构的东西，这些东西是由各个公司主导的，变化就非常快，你看 Grunt 发展了没多久，Gulp 就来挑战他了，然后又有 browserify、webpack 这些东西。<br>　　而我认为占重点的能力，则是非常稳定的，我认为能力是三大块：编程能力、架构能力、工程能力。<br>　　编程能力，就是用代码解决问题的能力，你编程能力越强，就能解决越复杂的问题，细分又有调试、算法、数据结构、OS 原理等这些的支撑，你才能解决各种麻烦的问题。<br>　　架构能力，则是解决代码规模的问题，当一个系统足够复杂，你会写每一块，能解决每一个问题，不等于你能搞定整个系统，这就需要架构能力，架构能力包含了一些意识，比如解耦、接口隔离，也包含认识业务建立抽象模型，也有一些常见的模式，比如经典的 MVC，还有设计层面，面向对象、设计模式等等。<br>　　最后工程能力，则是解决协作的问题，当系统规模更大，光靠一个人，是没办法完成的，如何保证几个高手互相能够配合好？如何保证项目里面水平最差的人不拖后腿？这个工程化建设，往往会跨越多个业务，以汇报关系上的团队为单位来做。包括前后端解耦，模块化，质量保证，代码风格，等等。<br>　　其实不难看出来，这三项，其实是有顺序的，低等级、小团队，编程能力一项就能应付，越资深的前端，越大的公司和团队，越是需要后面的技能，但是这里我要强调一点，其实资深前端，大团队，对能力的需求，是既要还要——不是说资深的前端，编程能力就可以变差。<br>　　社区总会有一些声音，对工程能力，对架构能力持有一种抵触的态度，觉得比较虚，觉得不需要。实际上以某些人所在的岗位来说，也没错，毕竟公司、团队的状态确实可能用不到，但是以个人成长的角度来看，就是大错特错。<br><img src="http://gw.alicdn.com/bao/uploaded/TB1L9VmMXXXXXc0XVXXXXXXXXXX-1729-990.png" alt=""><br>　　下面我们来具体讲讲，关于知识的学习。<br>　　对知识，我一直有个观点，叫做宁缺毋滥，这个图片上写了一句好前端才分对错，是的，其实很多人，他学习东西的时候就喜欢挑，挑简单的学，书选择最”深入浅出”的，在这种心态下，没有任何一丝学好的可能性，所以我对知识学习的目标，理解为亮点，一曰准确，二曰全面。当年学习一部分知识，如果你能做到这两点，那你将来在业务上做技术决策的时候，你面对面试官技术问题的时候，信心跟你只看过皮毛是完全不一样的。<br>　　怎么做到这两点呢？我想路子肯定有很多，而我的答案，我这里要分享的，是“建立自己的知识体系”。<br>　　如何建立自己的知识体系呢？我个人总结的经验，是下面几个步骤：</p><h4 id="第一步，寻找线索。"><a href="#第一步，寻找线索。" class="headerlink" title="第一步，寻找线索。"></a>第一步，寻找线索。</h4><p>　　你要了解一个知识，比如我想学 Web 平台的 API 了，当然可以先找一本书，看看别人都写了什么，但是我不喜欢这么干。<br>　　我大学里，学前端的东西，为了找个 id 和 name 的区别，曾经要借十几本书来，对比着看，那个时候，是真的没人告诉我，什么书比较好。所以我对别人总结好的知识，第一反应是质疑，不信。<br>　　所以我比较推荐，找一些比较准确的，你可以确定它真的足够全面的资料当作线索。对 Web 平台的 API，我就用反射：<br><img src="http://gw.alicdn.com/bao/uploaded/TB1COtpMXXXXXbwXVXXXXXXXXXX-1224-924.png" alt=""><br>　　浏览器里给出来的这个属性列表是不会骗人的，用这个东西作为线索，我就很有信心。<br>　　同样可能比较适合做的资料，还有一些标准文档的附录，和源代码里的结构定义。</p><h4 id="第二步，是建立联系。"><a href="#第二步，是建立联系。" class="headerlink" title="第二步，是建立联系。"></a>第二步，是建立联系。</h4><p>　　比如说，看下面几个 DOM 属性：<br><img src="http://gw.alicdn.com/bao/uploaded/TB1_AJIMXXXXXXeXXXXXXXXXXXX-1202-352.png" alt=""><br>　　这里，左边一列是操作 Node 的，右边一列是操作 Element 的，它就存在一定的对应关系。<br>　　一般来说，我们找对应关系的方式有以下几个依据：<br>　　美感<br>　　完备性<br>　　操作同一组数据<br>　　特别提一下，操作同一组数据，正是面向对象的核心概念，对前端而言，有点不一样的是，所有的 API，根都是 window，所以，其实大部分的 API，可以依据面向对象的数据和操作的观点进行划分。</p><h4 id="第三步，是分类。"><a href="#第三步，是分类。" class="headerlink" title="第三步，是分类。"></a>第三步，是分类。</h4><p>　　这里我给出一个实际一些的例子，下图是我对 zepto(移动简化版jQuery)，的 API 分类<br><img src="http://gw.alicdn.com/mt/TB1DbJqMXXXXXbBXVXXXXXXXXXX-800-1173.png" alt=""><br>　　建立联系以后，我们依据知识之间的联系，进行分类，就可以得到一张图谱，在这个图里面，你就可以非常清楚地知道，哪些知识，是非常重要的，哪些，其实是可以互相替代的。<br>　　而一旦有你之前没见过的东西，你又能通过把它放到图谱里，来快速理解它，或者找出一些很好的替代方案。<br>　　比如说面试的时候，如果面试官问你 bind 和 unbind 怎么用，你还不会，这时候，如果你心里有这张图，你就不至于一脸懵了，你可以说，虽然我不知道 bind 和 unbind，但是我知道 live 和 die 啊，我又知道 on 和 off 啊。<br>　　这张图里我们就可以看出，collection 里面的东西，多半没什么用，而节点操作里，肯定就都很有用。<br>　　第四步，是追本溯源。<br>　　当我对一个知识体系的全貌有了概念以后，占了全面两个字，接下来需要确认它的准确性。很多知识，在社区，会有很多的争议，该相信谁呢，这是个问题。而我的答案，就是追本溯源，去找它最初的讨论和定义。<br>　　有一个真实的案例，就是闭包这个概念，曾经我们很多人的理解都是错的，把闭包和 scope 的概念给混淆起来，认为闭包是函数的执行环境上下文，但是有一个叫做 hax 的（很多人应该都认识他，哈哈），他就对此提出了质疑，认为闭包就是函数。于是我就去查证闭包的概念。<br>　　大家都知道，wiki 其实是不准确的，但是其中有一段，基本不会太有问题，就是历史。下图是 closure 这个词条的历史部分：<br><img src="http://gw.alicdn.com/bao/uploaded/TB1d1XsMXXXXXXBXVXXXXXXXXXX-2263-430.png" alt=""><br>　　从这段历史里，我找到了一个名字， Peter J Landin，他是提出者，那么，我就去看看他到底是怎么说的，于是我去 google 学术搜索，找他的文章<br><img src="http://gw.alicdn.com/bao/uploaded/TB1lEdkMXXXXXXOaXXXXXXXXXXX-1388-551.png" alt=""><br>　　果然找到了，于是我们看看原始的文件<br><img src="http://gw.alicdn.com/bao/uploaded/TB1S9XiMXXXXXaLaXXXXXXXXXXX-751-477.png" alt=""><br>　　这个定义，对应到我们今天 JS 里的闭包，是稍微有点区别的，但是它毫无疑问，是包含了两个部分：环境部分和控制（代码）部分，所以其实，闭包就是对应着 JS 的函数，而之前，普遍的观点是认为闭包只包含环境。<br>　　所以这个追溯的过程，能够帮我们真正搞清楚对错。<br>　　除了 wiki-google 学术搜索的组合，还有一些邮件列表和 github 提交历史，也是非常适合去查证一些概念和技术的历史的。<br>　　最后说，我讲的这个建立知识体系的过程，是不断接受新知识，挑战、质疑原有的体系，推翻再重建，每一次循环，你的知识体系都变得更加坚固，更加强大。<br><img src="http://gw.alicdn.com/bao/uploaded/TB1wVBmMXXXXXX0aXXXXXXXXXXX-975-767.png" alt=""><br><img src="http://gw.alicdn.com/bao/uploaded/TB1KQhAMXXXXXXUXpXXXXXXXXXX-1732-973.png" alt=""><br>　　下面分享的一部分，是关于能力培养。<br>　　能力培养其实重要性很高，但是其实说起来，内容却很少。只有两点: 教材、训练。<br>　　对知识学习，我是主张建立自己的体系，不要去相信书，但是对能力培养，我的观点就刚好相反，我觉得能力的体系，恰恰是难以自己建立的，需要教材去指导。这是由两者的复杂程度和变化速度决定的。<br>　　想培养能力，就要找经典的教材来学习，像算法导论，The C++ Programming Language这些经典，几十年都没有过时。<br>　　注意这里我用了教材，而不是书。<br>　　教材和书最大的区别，就是有没有习题。<br>　　在我看来，内容再难的书可以一星期读两本，但是教材一定不行，教材一定得花几个月的时间，一边读一边做习题。<br>　　于是谈到训练。<br>　　其实有个事实是，工作以后，只有极少数人仍然能够做到训练，比如我自己的编程能力，我自觉工作 7、8 年，几乎没有过进步。<br>　　训练应该是系统的（需要教材）、主动的，这两个特点不可或缺，有人会觉得，我真的工作很辛苦，每天都要加班，但是其实，任何被动的痛苦，都没法给人带来进步，你的痛苦倒是可能给老板带来更多收入。<br>　　如果面临困境，可以选择系统训练来提升自己，但是对大部分人来说，可能更乐于选择一个一个变通的办法：养成习惯，让工作变得更有挑战。<br>　　这个事情其实有不少理论，比较有名的是 Noel Tichy 提出的心理舒适区、学习区和恐慌区。选择一份对自己来说具有挑战性的工作，正面解决问题。<br>　　技术圈里流行一个笑话，说的是一个人，工作了三年，却只有一年的经验，因为后面两年都在重复第一年的工作。<br>　　所以我们要做的事，就是永远不重复劳动，当你觉得现在的工作，越来越舒适，越来越缺少风险的时候，就应该引起警惕了。<br>　　而虽然训练是个很困难的事情，其实大家也不必过于担忧，虽然到处都是“一万小时训练”的言论，现在各大公司的招聘门槛，在我看来应该都卡在几百小时训练的程度。所以我想说，一万小时太久，只争朝夕。希望看到大家成为更好的前端，做更好的自己。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：寒泉 [&lt;a href=&quot;http://kb.cnblogs.com/page/545784/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一个前端的自我修养&lt;/a&gt;]&lt;br&gt;　　今天给大家分享的主题是前端的自我成长，这是一个关于成长的话题。&lt;br
      
    
    </summary>
    
      <category term="分享转载" scheme="http://zhangyi5628.github.io/categories/%E5%88%86%E4%BA%AB%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="http://zhangyi5628.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>web移动端开发调试方法</title>
    <link href="http://zhangyi5628.github.io/2016/08/03/web%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <id>http://zhangyi5628.github.io/2016/08/03/web移动端开发调试方法/</id>
    <published>2016-08-03T03:44:58.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>web移动端开发调试方法<br><a href="http://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="noopener">Charles 从入门到精通</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;web移动端开发调试方法&lt;br&gt;&lt;a href=&quot;http://blog.devtang.com/2015/11/14/charles-introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Charles 从入门到精通&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="移动端开发" scheme="http://zhangyi5628.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="调试" scheme="http://zhangyi5628.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6 你可能不知道的事 - 基础篇</title>
    <link href="http://zhangyi5628.github.io/2016/07/29/ES6-%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://zhangyi5628.github.io/2016/07/29/ES6-你可能不知道的事-基础篇/</id>
    <published>2016-07-29T08:01:43.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载之前先贴一个ES6语法文档<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a><br>转自：<a href="http://taobaofed.org/blog/2016/07/22/es6-basics/" target="_blank" rel="noopener">ES6 你可能不知道的事 - 基础篇</a></p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>ES6，或许应该叫 ES2015（2015 年 6 月正式发布），对于大多数前端同学都不陌生。<br>首先这篇文章不是工具书，不会去过多谈概念，而是想聊聊关于每个特性 你可能不知道的事，希望能为各位同学 正确使用 ES6，提供一些指导。<br>对于 ES6，有些同学已经在项目中有过深入使用了，有些则刚刚开始认识他，但不论你是属于哪一类，相信这篇文章都有适合你的部分。针对文章中的问题或不同意见，欢迎随时拍砖、指正。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Let-Const"><a href="#Let-Const" class="headerlink" title="Let + Const"></a>Let + Const</h3><p>这个大概是开始了解 ES6 后，我们第一个感觉自己完全明白并兴致勃勃的开始使用的特性。</p><p>以如下方式使用的同学请举下手？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line"><span class="keyword">const</span> REG_GET_INPUT = <span class="regexp">/^\d&#123;1,3&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义配置项</span></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  isDev : <span class="literal">false</span>,</span><br><span class="line">  pubDir: <span class="string">'./admin/'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 gulp</span></span><br><span class="line"><span class="keyword">let</span> gulp    = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入gulp相关插件</span></span><br><span class="line"><span class="keyword">let</span> concat  = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"><span class="keyword">let</span> uglify  = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">let</span> cssnano = <span class="built_in">require</span>(<span class="string">'gulp-cssnano'</span>);</span><br></pre></td></tr></table></figure></p><p>很多人看完概念之后，第一印象都是：“const 是表示不可变的值，而 let 则是用来替换原来的 var 的。”<br>所以就会出现上面代码中的样子；一段代码中出现大量的 let，只有部分常量用 const 去做定义，这样的使用方式是错误的。</p><h3 id="你可能不知道的事"><a href="#你可能不知道的事" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h3><p>const 的定义是不可重新赋值的值，与不可变的值(immutable value)不同；const 定义的 Object，在定义之后仍可以修改其属性。<br>所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以const做定义。反之就 let 而言，他的使用场景应该是相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他。</p><blockquote><p>猜想：就执行效率而言，const 由于不可以重新赋值的特性，所以可以做更多语法静态分析方面的优化，从而有更高的执行效率。</p></blockquote><p>所以上面代码中，所有使用 let 的部分，其实都应该是用 const 的。</p><h3 id="Template-Strings（字符串模板）"><a href="#Template-Strings（字符串模板）" class="headerlink" title="Template Strings（字符串模板）"></a>Template Strings（字符串模板）</h3><p>字符串模板是我刚接触ES6时最喜欢的特性之一，他语法简洁，语义明确，而且很好的解决了之前字符串拼接麻烦的问题。<br>因为他并不是 “必须” 的，而且原有的字符串拼接思维根深蒂固，导致我们很容易忽视掉他。</p><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>我们先来看看他的一般使用场景：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = <span class="string">'hi all'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'jelly'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> conf = &#123;</span><br><span class="line">  fav: <span class="string">'Coding'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">const</span> msg = <span class="string">`<span class="subst">$&#123;start&#125;</span>, my name is <span class="subst">$&#123;getName()&#125;</span>, <span class="subst">$&#123;conf.fav&#125;</span> is my favourite`</span>;</span><br></pre></td></tr></table></figure></p><h3 id="你可能不知道的事-1"><a href="#你可能不知道的事-1" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 与引号混用</span></span><br><span class="line"><span class="keyword">const</span> wantToSay = <span class="string">`I'm a "tbfed"`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 支持多行文本</span></span><br><span class="line"><span class="keyword">const</span> slogan = </span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">I have a dream today!</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较适合写HTML</span></span><br><span class="line"><span class="keyword">const</span> resultTpl = </span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">  &lt;section&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/section&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><h3 id="Enhanced-Object-Literals（增强的对象字面量）"><a href="#Enhanced-Object-Literals（增强的对象字面量）" class="headerlink" title="Enhanced Object Literals（增强的对象字面量）"></a>Enhanced Object Literals（增强的对象字面量）</h3><p>增强的对象字面量是 ES6 中的升华功能，他设计了很多简写，这些简写不但保留了明确的语义，还减少了我们多余的代码量。<br>当他的使用成为一个习惯时，我们会看到自己代码变得更为优雅。</p><h3 id="你可能不知道的事-2"><a href="#你可能不知道的事-2" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const _bookNum = 4;<span class="comment">### Arrows and Lexical This（箭头函数）</span></span><br><span class="line">箭头函数是ES6中的一个新的语法特性，他的用法简单，形态优雅，备受人们青睐。</span><br><span class="line"></span><br><span class="line">大多数同学初识这个特性时，更多的仅仅用它作为函数定义的简写，这其实就有些屈才了。</span><br><span class="line"></span><br><span class="line">const basicConfig = &#123;</span><br><span class="line">  level: 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  // 直接指定原型对象</span><br><span class="line">  __proto__: basicConfig,</span><br><span class="line">  </span><br><span class="line">  // 属性简写</span><br><span class="line">  _bookNum,</span><br><span class="line">  </span><br><span class="line">  // 方法简写</span><br><span class="line">  <span class="function"><span class="title">getBookNum</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.bookNum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arrows-and-Lexical-This（箭头函数）"><a href="#Arrows-and-Lexical-This（箭头函数）" class="headerlink" title="Arrows and Lexical This（箭头函数）"></a>Arrows and Lexical This（箭头函数）</h3><p>箭头函数是ES6中的一个新的语法特性，他的用法简单，形态优雅，备受人们青睐。<br>大多数同学初识这个特性时，更多的仅仅用它作为函数定义的简写，这其实就有些屈才了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用箭头函数的写法</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  addOptions: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  </span><br><span class="line">    options.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name, opts</span>)</span>&#123;</span><br><span class="line">      </span><br><span class="line">      self[name] = self.addChild(name, opts);</span><br><span class="line">      </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数后的写法</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  addOptions: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    options.forEach(<span class="function">(<span class="params">name, opts</span>) =&gt;</span> &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>[name] = <span class="keyword">this</span>.addChild(name, opts);</span><br><span class="line">      </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以注意到上下两段代码的区别。<br>在未使用箭头函数前，我们在过程函数中使用父级 this，需要将其显式缓存到另一个中间变量中，因为过程函数有独立的 this 变量，会覆盖父级；使用箭头函数后，不但简写了一个过程函数（ forEach 的参数），还省略掉了 this 的中间变量的定义。</p><h3 id="原因：箭头函数没有独立执行上下文（-this-），所以其内部引用-this-对象会直接访问父级。"><a href="#原因：箭头函数没有独立执行上下文（-this-），所以其内部引用-this-对象会直接访问父级。" class="headerlink" title="原因：箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级。"></a>原因：箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级。</h3><blockquote><p>插播：原来我们定义这个中间变量还有一个有趣的现象，就是明明千奇百怪，例如 self, that, me, _that, _me, Self…，快站出来说说你用过哪个，还是哪几个~</p></blockquote><p>当然，从这块我们也可以看出，箭头函数是无法替代全部 function 的使用场景的，例如我们需要有独立 this 的函数。</p><h3 id="你可能不知道的事-3"><a href="#你可能不知道的事-3" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h3><blockquote><ul><li>箭头函数不但没有独立 this，他也没有独立的 arguments，所以如果需要取不定参的时候，要么使用 function，要么用 ES6 的另一个新特性 rest（具体在 rest 中会有详解）。</li><li>箭头函数语法很灵活，在只有一个参数或者只有一句表达式做方法体时，可以省略相应括号。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整写法</span></span><br><span class="line"><span class="keyword">const</span> getOptions = <span class="function">(<span class="params">name, key</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略参数括号</span></span><br><span class="line"><span class="keyword">const</span> getOptions = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略参数和方法体括号</span></span><br><span class="line"><span class="keyword">const</span> getOptions = <span class="function"><span class="params">key</span> =&gt;</span> <span class="built_in">console</span>.log(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数或方法体，括号不能省略</span></span><br><span class="line"><span class="keyword">const</span> noop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>有个简单小栗子，这一灵活的语法在写连续的Promise链式调用时，可以使代码更加优雅<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitPromise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> git.add())</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> git.commit())</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> git.log())</span><br><span class="line">  .then(<span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> git.push())</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      utils.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><h3 id="Destructuring（解构）"><a href="#Destructuring（解构）" class="headerlink" title="Destructuring（解构）"></a>Destructuring（解构）</h3><p>解构这个特性可以简单解读为分别定义，用于一次定义多个变量，常常用于分解方法返回对象为多个变量，分别使用。<br>使用过ES6的同学应该或多或少接触过这个特性，但是你可能不知道它如下几个用法：</p><h3 id="你可能不知道的事-4"><a href="#你可能不知道的事-4" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bookSet = [<span class="string">'UED'</span>, <span class="string">'TB fed'</span>, <span class="string">'Not find'</span>];</span><br><span class="line"><span class="keyword">const</span> bookCollection = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">book1</span>: <span class="string">'UED'</span>, <span class="attr">book2</span>: <span class="string">'TB fed'</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 解构也可以设置默认值</span></span><br><span class="line"><span class="keyword">const</span> &#123;book1, book3 = <span class="string">'Not find'</span>&#125; = bookCollection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 解构数组时候是可以跳过其中某几项的</span></span><br><span class="line"><span class="keyword">const</span> [book1,,book3] = bookSet;  <span class="comment">// book1 = 'UED', book3 = 'Not find'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 解构可以取到指定对象的任何属性，包括它包含的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">length</span>: setLength&#125; = bookSet;  <span class="comment">// setLength = 3</span></span><br></pre></td></tr></table></figure><h3 id="Rest-Spread"><a href="#Rest-Spread" class="headerlink" title="Rest + Spread"></a>Rest + Spread</h3><p>Rest 和 Spread 主要是应用 … 运算符，完成值的聚合和分解。</p><h3 id="你可能不知道的事-5"><a href="#你可能不知道的事-5" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. rest 得到的是一个真正的数组而不是一个伪数组</span></span><br><span class="line"><span class="keyword">const</span> getOptions = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args.join); <span class="comment">// function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. rest 可以配合箭头函数使用，达到取得所有参数的目的</span></span><br><span class="line"><span class="keyword">const</span> getOptions = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args); <span class="comment">// array</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. spread 可以用于解构时，聚合所得的值</span></span><br><span class="line"><span class="keyword">const</span> [opt1, ...opts] = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. spread 可以用于数组定义</span></span><br><span class="line"><span class="keyword">const</span> opts = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span><br><span class="line"><span class="keyword">const</span> config = [<span class="string">'other'</span>, ...opts];</span><br></pre></td></tr></table></figure><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>ES6 中实现的一个语法糖，用于简化基于原型集成实现类定义的场景。<br>虽然有很多人不太喜欢这个特性，认为它作为一个简单增强扩展，并没有其他语言 class 应有的特点。<br>但是就我自己观点来看，还是感觉这样一种写法确实比原有的原型继承的写法语义更清晰、明确，而且语法更简单。</p><p>同样，可能有些用法是你之前容易忽略掉的，在此做个补充。</p><h3 id="你可能不知道的事-6"><a href="#你可能不知道的事-6" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 静态变量</span></span><br><span class="line"><span class="comment">// ES6 的类定义实现了静态方法的定义，但静态变量呢？</span></span><br><span class="line"><span class="comment">// 可以用如下方式实现: </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TbFedMembers</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get HuaChen()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'jelly'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">TbFedMembers.HuaChen; <span class="comment">// "化辰"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 私有属性（私有属性有多种实现方式，只谈及其中一种）</span></span><br><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">const</span> TbFedMembers = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> HuaChen = <span class="string">'jelly'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    getOneMemberName()&#123;</span><br><span class="line">      <span class="keyword">return</span> HuaChen;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h3><p>Promise 不只是一个对象、一个语法，他更是一种异步编程方式的变化<br>相信使用过 ES6 的同学都已经开始尝试了 Promise，甚至在不支持ES6的时候，已经开始使用一些基于 Promise 思想的开源框架。</p><p>那么我们之前用 Promise 究竟用的对么？有什么需要注意的点呢？</p><h3 id="你可能不知道的事-7"><a href="#你可能不知道的事-7" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 多个异步任务同时执行用 Promise.all，顺序执行使用链式调用</span></span><br><span class="line"><span class="comment">// Promise.all</span></span><br><span class="line"><span class="built_in">Promise</span></span><br><span class="line">  .all([jsBuildPromise, cssBuildPromise])</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// chain</span></span><br><span class="line">jsBuildPromise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> cssBuildPromise)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Promise 的链式调用需要每一个过程返回一个 Promise 对象才能保证顺序执行</span></span><br><span class="line">gitPromise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> git.add())  <span class="comment">// 正确，箭头函数简写</span></span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    git.commit(); <span class="comment">// 错误，函数返回 undefined，会立即执行下一过程</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> git.log(); <span class="comment">// 正确</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Promise 需要调用 catch 方法来捕获错误，而且过程内的错误不会阻塞后续代码执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  f;  <span class="comment">// not define error !</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)  <span class="comment">// show 'f is not define'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'error test'</span>);  <span class="comment">// 此行可以被正常执行</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>基础篇主要是讲了我们最常用的一些特性，后续如果大家感兴趣，还可以再来个 “进阶篇”，最后，希望文章中的部分内容可以对大家理解和使用 ES6 有所帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载之前先贴一个ES6语法文档&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://es6.ruanyifeng.com/&lt;/a&gt;&lt;br&gt;转自：&lt;a href=&quot;http://t
      
    
    </summary>
    
      <category term="javascript" scheme="http://zhangyi5628.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://zhangyi5628.github.io/tags/javascript/"/>
    
      <category term="ES6" scheme="http://zhangyi5628.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>常用 Git 命令清单</title>
    <link href="http://zhangyi5628.github.io/2016/07/26/%E5%B8%B8%E7%94%A8-Git-%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/"/>
    <id>http://zhangyi5628.github.io/2016/07/26/常用-Git-命令清单/</id>
    <published>2016-07-26T10:49:18.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自：阮一峰 [<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单</a>]</p><p>我每天使用 Git ，但是很多命令记不住。<br>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="Alt text"></p><p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h3 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure></p><h3 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h3 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h3 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h3 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h3 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h3 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把一个分支中的修改检出到另一个分支的暂存区</span></span><br><span class="line">$ git checkout [branchname] [file]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：阮一峰 [&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;常用 Git 命令清单&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;我每天使
      
    
    </summary>
    
      <category term="Git" scheme="http://zhangyi5628.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://zhangyi5628.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>前端开发中如何选用图片格式</title>
    <link href="http://zhangyi5628.github.io/2016/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/"/>
    <id>http://zhangyi5628.github.io/2016/07/18/前端开发中如何选用图片格式/</id>
    <published>2016-07-18T09:40:38.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-图像术语"><a href="#一-图像术语" class="headerlink" title="一.图像术语"></a>一.图像术语</h2><h3 id="图形和照片"><a href="#图形和照片" class="headerlink" title="图形和照片"></a>图形和照片</h3><ul><li>图形<ul><li>网站的logo、草图、图表、大部分动画和图标都属于图形。这些图像通常由连续的线条或者其他尖锐的颜色过渡组成，颜色数量相对较少</li></ul></li><li><p>照片</p><ul><li>照片通常有百万数量级的颜色，并且包含平滑的颜色过渡和渐变，想象一下用相机拍摄的日落时的照片。绘画作品的图像（比如蒙娜丽莎的微笑）更接近于照片，而不是图形就图像格式而言，GIF通常用来显示图形，而JPEG更适合显示照片。PNG两者都适合，甚至用调色板PNG（palette PNG）显示图形比GIF会更好一些<h3 id="像素和RGB"><a href="#像素和RGB" class="headerlink" title="像素和RGB"></a>像素和RGB</h3>图像由像素组成，像素是图像中最小的信息单元。我们可以使用不同的颜色模型来描述像素，在计算机图像处理上，RGB颜色模型是最常用的一种<br>在RGB颜色模型中，采用包含红（R）、绿（G）和蓝（B）的数量多少的方式来描述一个像素。R、G和B被称为成分（又称为通道），每种成分的强度值范围在0-255之间。我们经常在HTML和CSS中使用的是十六进制的成分值，范围从00~FF。将不同强度的成分组合在一起，就可以获得不同的颜色。比如：</li></ul><ul><li><p>红色是rgb(255, 0, 0)或十六进制的#FF0000</p></li><li><p>蓝色是rgb(0, 0, 255)或十六进制的#0000FF</p></li><li><p>灰色阴影很可能有着三个相同的成分值，比如，rgb(238, 238, 238)或十六进制的#EEEEEE</p><h3 id="真彩色图像和调色板图像格式"><a href="#真彩色图像和调色板图像格式" class="headerlink" title="真彩色图像和调色板图像格式"></a>真彩色图像和调色板图像格式</h3><p>使用RGB颜色模型到底可以展现多少种不同的颜色呢？答案是1600万种：256<em>256</em>256（或者2的24次方）可以得到16777216种组合。可以支持这么颜色的图像格式叫做真彩色图像格式，比如JPEG和真彩色类型的PNG  </p><p>为了在存储图像信息时节省一些空间，有一项技术是将图像中各种不同的颜色提取出来建立一个表，这个表通常叫做调色板（也可以称为索引）。有了这个颜色表，就可以通过将调色板中的条目和每个像素重新匹配，达到重新绘制整个图像的目的  </p><p>调色板可以包含任意RGB颜色值，但是最经常使用的调色板图像格式——GIF和PNG8都会限制调色板中最多只能包含256种颜色。这不是说你只可以中256种已经定义号的颜色中选择，恰恰相反，你可以从1600+万的颜色中选择你需要的值，但是单个图像中最多只能包含256种颜色</p><h3 id="透明和alpha通道（RGBA）"><a href="#透明和alpha通道（RGBA）" class="headerlink" title="透明和alpha通道（RGBA）"></a>透明和alpha通道（RGBA）</h3><p>RGBA并非另一种截然不同的颜色模型，而是在RGB基础上做了扩展，额外的成分A代表alpha透明，值的范围也是从0~255，但实际上不同的程序和库会将透明定义为从0%~100%的百分比，或者从0-127的值。alpha通道描述了投过图像像素可以看到下面内容的程度</p><p>假设已经做出了一个网页，设置了背景，并在上面放置了一个蓝色的图像。如果图像上某个像素的透明度设置为0，那么该像素下面的背景就不可见。如果alpha透明度设置为最大值100%，那么图像上的像素将会隐藏，而背景则会“浮现出来”。加入设置为中间值，比如50%，就可以同时看到背景和图像上的像素</p><h3 id="隔行扫描"><a href="#隔行扫描" class="headerlink" title="隔行扫描"></a>隔行扫描</h3><p>当网速很慢时，大图像会随着下载的进度逐行显示，从上到下每显示一行，缓慢地向下递进，为了提高用户体验，部分图像格式支持对那些连续采样的图像进行隔行扫描。隔行扫描可以让用户在完整下载图像之前，看到图像的一个粗略版本，从心理上消除页面被延迟加载的感觉</p></li></ul></li></ul><h2 id="二-不同图像格式的特性"><a href="#二-不同图像格式的特性" class="headerlink" title="二.不同图像格式的特性"></a>二.不同图像格式的特性</h2><ul><li>GIF、JPEG和PNG这3种格式的区别：<h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h3>图形交换格式（Graphics Interchange Format）的缩写，是一种调色板图像格式，有以下特性：</li><li>透明<ul><li>GIF允许一个二进制（是/否）类型的透明度，每个像素要么是完全透明的（不包含颜色），要么是完全不透明的（包含一个单色）。这就意味着它不支持alpha（可变的）透明，取而代之的是，调色板中的某个颜色可以被标记为表示透明，而透明像素则会被分配为这个颜色值。所以，如果你为GIF设置了透明像素，那么就会“消耗”一个调色板条目</li></ul></li><li>动画<ul><li>GIF格式支持动画，包含动画的图像由若干帧组成，就像几个图像同时包含在一个文件中一样，大家普遍认为GIF动画很烦人，这是因为在网络发展初期它被滥用了，那时候大家用GIF来制作闪烁文字、旋转的@标志等等。GIF动画现在是有一些应用，比如广告条（虽然现在这已经主要是Flash的天下了），还有在富互联网（RIAs）应用中出现的“加载中”指示符</li></ul></li><li>无损<ul><li>GIF是无损的，也就是说你可以打开任意一个GIF文件，做一些修改，保存关闭时不会损失任何质量</li></ul></li><li>逐行扫描<ul><li>当生成GIF文件时，会使用一个压缩算法（叫做LZW）来减小文件的大小。当压缩GIF时，会从上到下一行一行的对像素进行扫描，这种情况下，当图像在水平方向有很多重复颜色时，可以获得更好的压缩效果。比如，有一个500*10像素的图像（宽500px高10px），图像上包含一些条纹，就是说水平方向是由相同颜色线条组成的，将这个图像旋转90度后（宽10px高500px），其垂直方向是由相同颜色的条纹组成的，此时后者的文件要大于前者</li><li>GIF支持可选的隔行扫描<br>由于GIF有256色的限制，所以不适合用来显示照片，照片所需的颜色数量远大于这个数量级。GIF更适合用来显示图形（图标、logo和图表），但PNG8是用来显示图形的最佳格式，所以，只有在需要动画时才应该用GIF<br>GIF格式中使用的LZW无损数据压缩算法，在以前是受专利保护的，但是这个专利在2004年过了保护期，现在已经可以自由使用GIF了</li></ul></li></ul><h3 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h3><ul><li>有损<ul><li>JPEG是一种有损的格式，用户可以设置自定义质量级别，这个级别决定了有多少图像信息会被丢弃。质量级别的值从0到100，但是就算设置为100，也同样会有一定程度的质量损耗<br>当要对某个图像进行多项编辑操作时，最好使用无损图像格式来保存中间结果，然后在完成所有的修改后另存为JPEG格式，否则将会在每次保存时都损耗一些质量<br>但也有少数操作时无损的，比如：<ul><li>旋转（只有在旋转90度、180度和270的情况下）</li><li>裁剪</li><li>翻转（水平或者垂直）</li><li>从标准模式切换到渐进模式，反之亦然</li><li>编辑图像的元数据</li></ul></li></ul><ul><li>透明和动画<ul><li>JPEG不支持透明或动画</li></ul></li><li>隔行扫描<ul><li>除了默认的标准JPEG（Baseline JPEG），还有一种渐进JPEG（Progressive JPEG），支持隔行扫描。Internet Explorer不会逐步地渲染渐进JPEF图像，而是在图像完全下载时立即全部显示出来<br>JPEG是web上用来存储照片的最佳格式，也被广泛应用在数码相机中，然而，这种格式不适合用来存储图形，因为有损的压缩方法将线条和清晰的颜色过渡都变成了“大色块”</li></ul></li></ul></li></ul><h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><pre><code>为了弥补GIF格式的缺点并规避LZW算法的专利问题，PNG（Portable Network Graphics，便携式网络图片）应运而生。实际上，人们常开玩笑说PNG代表“PNG is Not Gif”的递归碎屑，有以下特性：</code></pre><ul><li>真彩色和调色板PNG格式<ul><li>PNG格式有几种子类型，但它们大致可以分为两种：调色板PNG格式和真彩色PNG格式。可以使用调色板PNG格式来代替GIF格式，使用真彩色PNG格式来他代替JPEG格式</li></ul></li><li>透明<ul><li>PNG支持完全的alpha透明，在Internet Explorer6中使用这种特性会出现问题（透明区域变成粉蓝色，锯齿等等，更多相关问题请查看IE6下png背景不透明问题的综合拓展）</li></ul></li><li>动画<ul><li>虽然已经有相关实验和实际应用存在，但截至目前，针对动画PNG格式，还没有跨浏览器的解决方案</li></ul></li><li>无损<ul><li>与JPEG不同的是，PNG是一种无损的图像格式：多次编辑不会降低其质量。这使得用真彩色PNG来保存JPEG的修改过程的中间产物非常合适</li></ul></li><li>逐行扫描  <ul><li>和GIF格式一样，相对于那些垂直方向有重复颜色的图像来说，PNG格式对那些水平方向有重复颜色的图像压缩比更高</li></ul></li><li>隔行扫描<ul><li>PNG支持隔行扫描，并使用了比GIF更好的算法，它允许对真是图像进行更好的“预览”，但是支持隔行扫描的PNG图像在文件大小上会更大一些  </li></ul></li></ul><h2 id="三-PNG"><a href="#三-PNG" class="headerlink" title="三.PNG"></a>三.PNG</h2><p>PNG分为PNG8、PNG24和PNG32：</p><ul><li>PNG8<ul><li>调色板PNG</li></ul></li><li>PNG24<ul><li>真彩色PNG，但不包括alpha通道</li></ul></li><li>PNG32<ul><li>真彩色PNG，包括alpha通道</li></ul></li></ul><h3 id="PNG和GIF"><a href="#PNG和GIF" class="headerlink" title="PNG和GIF"></a>PNG和GIF</h3><p>除了不支持动画以外，调色板PNG拥有GIF的所有功能。此外，它还支持alpha透明，并且通常压缩比更高，文件大小更小，所以，应该尽可能使用PNG8来代替GIF<br>有一个例外是颜色数很少的小图像，这是GIF的压缩率可能会更高一些，但是这种小图像其实应该被放在CSS Sprite中，因为HTTP请求的开销已经大大超过节省的那点带宽，而且用PNG格式保存Sprite图像可以获得更高的压缩率</p><h3 id="PNG和JPEG"><a href="#PNG和JPEG" class="headerlink" title="PNG和JPEG"></a>PNG和JPEG</h3><p>当图像中的颜色数超过256种时，需要使用真彩色图像格式——真彩色PNG或者JPEG。JPEG的压缩比更高，而且一般来说，JPEG也是照片存储的实际标准。但由于JPEG是有损的，而且在清晰的颜色过渡周围会有大色块，因此以下情况使用PNG更合适：</p><pre><code>+ 当图像的颜色略超过256种时，可以在不损耗任何可见质量的前提下，将图像转换为PNG8格式。令人惊奇的是，有时候就算你玻璃了1000种以上的颜色，都不会注意到图像中所发生的变化+ 当大色块变得不可接受时，比如说包含很多颜色的图像或软件菜单的截图，这时候PNG就是更好的选择</code></pre><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h2><p>按照上面的解释，一般情况下PNG似乎是最好的选择，动画用GIF，高清图片用JPEG</p><table><thead><tr><th>类型</th><th>压缩方式</th><th>色彩通道</th><th>透明度</th><th>是否支持动画</th><th>压缩算法</th><th>多图层</th></tr></thead><tbody><tr><td>PNG-8</td><td>无损</td><td>索引256色</td><td>索引全透明</td><td>否</td><td>逐行扫描</td><td>无</td></tr><tr><td>PNG-24</td><td>无损</td><td>真彩16.7million色</td><td>Alpha半透明（IE6背景灰色）</td><td>否</td><td>逐行扫描</td><td>无</td></tr><tr><td>PNG-32</td><td>无损</td><td>真彩16.7million色</td><td>Alpha半透明（IE6背景灰色</td><td>否</td><td>逐行扫描</td><td>firework中可编辑</td></tr><tr><td>GIF</td><td>无损</td><td>索引256色</td><td>索引全透明</td><td>支持</td><td>逐行扫描</td><td>无</td></tr><tr><td>JPG</td><td>有损</td><td>真彩16.7million色</td><td>无</td><td>无</td><td>8*8</td><td>无</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-图像术语&quot;&gt;&lt;a href=&quot;#一-图像术语&quot; class=&quot;headerlink&quot; title=&quot;一.图像术语&quot;&gt;&lt;/a&gt;一.图像术语&lt;/h2&gt;&lt;h3 id=&quot;图形和照片&quot;&gt;&lt;a href=&quot;#图形和照片&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="图片格式" scheme="http://zhangyi5628.github.io/tags/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/"/>
    
      <category term="CSS" scheme="http://zhangyi5628.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>input type=file accept中可以限制可选的文件类型</title>
    <link href="http://zhangyi5628.github.io/2016/06/07/input-type-file-accept%E4%B8%AD%E5%8F%AF%E4%BB%A5%E9%99%90%E5%88%B6%E5%8F%AF%E9%80%89%E7%9A%84%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"/>
    <id>http://zhangyi5628.github.io/2016/06/07/input-type-file-accept中可以限制可选的文件类型/</id>
    <published>2016-06-07T08:35:55.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上传文件的时候，通过accept属性可以限制可选文件的类型，当设置改属性是，可以让用户在浏览上传文件时，只能选择指定的文件类型。那么不同的文件类型，accept值应该如何设置了？<br>见下表：</p><table><thead><tr><th>文件类型</th><th>MIME(accept属性值)</th></tr></thead><tbody><tr><td>图片（.png,.jpg等所有格式的图片）</td><td>image/*</td></tr><tr><td>*.doc</td><td>application/msword</td></tr><tr><td>*.docx</td><td>application/vnd.openxmlformats-officedocument.wordprocessingml.document</td></tr><tr><td>*.xls</td><td>application/vnd.ms-excel</td></tr><tr><td>*.xlsx</td><td>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</td></tr><tr><td>*.txt</td><td>text/plain</td></tr><tr><td>*.html</td><td>text/html</td></tr><tr><td>Video(.avi, .mpg, .mpeg, .mp4)</td><td>video/*</td></tr><tr><td>Audio(.mp3, .wav, etc)</td><td>audio/*</td></tr><tr><td>*.pdf</td><td>application/pdf</td></tr><tr><td>*.csv</td><td>text/csv</td></tr><tr><td>*.css</td><td>text/css</td></tr><tr><td>*.gif</td><td>image/gif</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上传文件的时候，通过accept属性可以限制可选文件的类型，当设置改属性是，可以让用户在浏览上传文件时，只能选择指定的文件类型。那么不同的文件类型，accept值应该如何设置了？&lt;br&gt;见下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件类型&lt;/th&gt;
      
    
    </summary>
    
      <category term="Html" scheme="http://zhangyi5628.github.io/categories/Html/"/>
    
    
      <category term="Html" scheme="http://zhangyi5628.github.io/tags/Html/"/>
    
      <category term="input" scheme="http://zhangyi5628.github.io/tags/input/"/>
    
      <category term="file" scheme="http://zhangyi5628.github.io/tags/file/"/>
    
      <category term="upload" scheme="http://zhangyi5628.github.io/tags/upload/"/>
    
  </entry>
  
  <entry>
    <title>webpack config配置简介</title>
    <link href="http://zhangyi5628.github.io/2016/05/21/webpack-config%E9%85%8D%E7%BD%AE%E7%AE%80%E4%BB%8B/"/>
    <id>http://zhangyi5628.github.io/2016/05/21/webpack-config配置简介/</id>
    <published>2016-05-21T01:06:36.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文只对webpack的一些简单配置（webpack.config.js）做介绍，并不深究。</p><h3 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h3><p>webpack 简单说就是模块加载器。在webpack中，所有的资源文件如js,css,图片等都看作是模块。<br>webpack 支持AMD,CommonJs以及ES6语法的模块加载系统。</p><h3 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h3><p>首先你要安装node.js和npm<br>其次为你的项目新建一个文件夹，然后输入 npm init，然后填写相关问题。<br>这样会为你创建了 package.json。<br>接下来把webpack 安装在本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack --save-dev</span><br></pre></td></tr></table></figure></p><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webpack-demo</span><br><span class="line">|-node_modules</span><br><span class="line">|-dist</span><br><span class="line">|-build</span><br><span class="line">|-src</span><br><span class="line">    |-app.js</span><br><span class="line">    |-component.jsx</span><br><span class="line">|-package.json</span><br><span class="line">|-webpack.config.js</span><br><span class="line">|-webpack.dist.config.js</span><br></pre></td></tr></table></figure><h3 id="webpack-config-js-开发环境配置文件"><a href="#webpack-config-js-开发环境配置文件" class="headerlink" title="webpack.config.js 开发环境配置文件"></a>webpack.config.js 开发环境配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line">var webpack = require(&quot;webpack&quot;);</span><br><span class="line">var node_modules = path.resolve(__dirname, &apos;node_modules&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;    //入口文件配置</span><br><span class="line">        js: &apos;./src/app.js&apos;,</span><br><span class="line">        vendor: [&apos;react&apos;, &apos;react-dom&apos;] </span><br><span class="line">        //引用的功能代码，这样配置可以把功能代码打包在一个文件中</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;build&apos;),</span><br><span class="line">        filename: &apos;./bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [&#123;</span><br><span class="line">            test: /\.jsx?$/,</span><br><span class="line">            exclude: /node_modules/,</span><br><span class="line">            loader: &apos;babel&apos;,</span><br><span class="line">            query: &#123;</span><br><span class="line">                presets: [&apos;react&apos;, &apos;es2015&apos;] //设置支持的ES6语法</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            test: /\.less$/,</span><br><span class="line">            loader: &apos;style!css!less&apos;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            test: /\.(eot|woff|woff2|ttf|svg)$/,</span><br><span class="line">            loader: &apos;url-loader&apos;</span><br><span class="line">                // loader: &apos;url-loader&apos;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            test: /\.(png|jpg|gif)$/,</span><br><span class="line">            loader: &quot;url-loader?limit=250000&quot;</span><br><span class="line">        &#125;],</span><br><span class="line">        noParse: [&apos;react&apos;, &apos;readct-dom&apos;] //忽略掉这些目录</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">        new webpack.NoErrorsPlugin(),</span><br><span class="line">        new webpack.optimize.CommonsChunkPlugin(&apos;vendor&apos;, &apos;vendor.bundle.js&apos;) </span><br><span class="line">        //设置支持把公用代码打包到一个问题就中</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="webpack-dist-config-js-生产环境配置文件"><a href="#webpack-dist-config-js-生产环境配置文件" class="headerlink" title="webpack.dist.config.js 生产环境配置文件"></a>webpack.dist.config.js 生产环境配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;);</span><br><span class="line">var path    = require(&apos;path&apos;);</span><br><span class="line">var config  = require(&apos;./webpack.config&apos;);</span><br><span class="line"></span><br><span class="line">config.output = &#123;   //修改输出地址</span><br><span class="line">  filename: &apos;./src/app.js&apos;,</span><br><span class="line">  publicPath: &apos;&apos;,</span><br><span class="line">  path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure><h3 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h3><p>把webpack的打包命令写在package.json中的script配置中，这样就不用每次输入很长的webpack命令。<br>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server&quot;,</span><br><span class="line">    &quot;deploy&quot;: &quot;NODE_ENV=production webpack -p --config webpack.dist.config.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文只对webpack的一些简单配置（webpack.config.js）做介绍，并不深究。&lt;/p&gt;
&lt;h3 id=&quot;webpack是什么&quot;&gt;&lt;a href=&quot;#webpack是什么&quot; class=&quot;headerlink&quot; title=&quot;webpack是什么&quot;&gt;&lt;/a&gt;we
      
    
    </summary>
    
      <category term="前端构建工具" scheme="http://zhangyi5628.github.io/categories/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="webpack" scheme="http://zhangyi5628.github.io/tags/webpack/"/>
    
      <category term="config" scheme="http://zhangyi5628.github.io/tags/config/"/>
    
      <category term="前端构建工具" scheme="http://zhangyi5628.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Mac 常用快捷键</title>
    <link href="http://zhangyi5628.github.io/2016/05/21/Mac-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://zhangyi5628.github.io/2016/05/21/Mac-常用快捷键/</id>
    <published>2016-05-21T00:18:23.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>收集Max OS X系统常用快捷键</p><h3 id="一、OS-X系统常用快捷键"><a href="#一、OS-X系统常用快捷键" class="headerlink" title="一、OS X系统常用快捷键"></a>一、OS X系统常用快捷键</h3><p>command+control+f: 进入或退出全屏模式<br>command+m: 最小化窗口</p><h3 id="二、iTerm"><a href="#二、iTerm" class="headerlink" title="二、iTerm"></a>二、iTerm</h3><p>iterm是我们程序员最熟悉的Mac软件之一了，现在的前端不运行命令行工具已经没法工作了，什么node,git,grunt,gulp,webpack…<br>command+enter: 进入或退出全屏模式<br>command+t: 新建标签<br>command+w: 关闭标签<br>command+f: 弹出查找模式<br>command+d: 垂直分隔（我必用，垂直开多个窗口）<br>command+shift+d: 水平分隔<br>command+(+): 放大文字<br>command+(-): 缩小文字<br>command+0: 缩放文字到正常比例<br>command+shift+h: 列出剪切板的历史记录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;收集Max OS X系统常用快捷键&lt;/p&gt;
&lt;h3 id=&quot;一、OS-X系统常用快捷键&quot;&gt;&lt;a href=&quot;#一、OS-X系统常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;一、OS X系统常用快捷键&quot;&gt;&lt;/a&gt;一、OS X系统常用快捷键&lt;/h3&gt;&lt;p&gt;c
      
    
    </summary>
    
      <category term="Mac" scheme="http://zhangyi5628.github.io/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://zhangyi5628.github.io/tags/Mac/"/>
    
      <category term="快捷键" scheme="http://zhangyi5628.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>HTTP请求流程简介</title>
    <link href="http://zhangyi5628.github.io/2016/05/13/Http%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://zhangyi5628.github.io/2016/05/13/Http请求流程简介/</id>
    <published>2016-05-13T06:37:09.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了“<a href="http://www.linux178.com/web/httprequest.html" target="_blank" rel="noopener">一次完整的HTTP事务是怎样一个过程？</a>”这篇博客深有感触，就想做个总结，把对于前端来说更重要的部分做个摘录。<br>HTTP属于TCP/IP模型中的应用层协议, TCP协议实现了数据流的传输。然而，人们更加习惯以文件为单位传输资源，比如文本文件，图像文件，超文本文档(hypertext document)。<br>超文本文档中包含有超链接，指向其他的资源。超文本文档是万维网(World Wide Web，即www)的基础。<br>HTTP协议解决文件传输的问题。HTTP是应用层协议，主要建立在TCP协议之上(偶尔也可以UDP为底层)。</p><h3 id="一次完整的HTTP请求的流程大体是这样："><a href="#一次完整的HTTP请求的流程大体是这样：" class="headerlink" title="一次完整的HTTP请求的流程大体是这样："></a>一次完整的HTTP请求的流程大体是这样：</h3><p>域名解析 —&gt; 发起TCP的3次握手 —&gt; 建立TCP连接后发起HTTP请求 —&gt; 服务器响应HTTP请求 —&gt;浏览器接收到Html代码 —&gt; 浏览器解析Html代码，并请求html代码中的资源（js、css、image等）—&gt;浏览器对页面进行渲染呈现给用户</p><h3 id="HTTP请求类型"><a href="#HTTP请求类型" class="headerlink" title="HTTP请求类型"></a>HTTP请求类型</h3><h4 id="1、GET：获取一个文档"><a href="#1、GET：获取一个文档" class="headerlink" title="1、GET：获取一个文档"></a>1、GET：获取一个文档</h4><p>大部分被传输到浏览器的html,js,css,image等资源都是通过GET方式发送出去的，它是获取资源的主要方法。</p><h4 id="2、POST：发送数据至服务器"><a href="#2、POST：发送数据至服务器" class="headerlink" title="2、POST：发送数据至服务器"></a>2、POST：发送数据至服务器</h4><p>受url长度、安全型等限制大多数获取数据的请求都不使用GET方法，而是使用POST。使用POST可以发送更多的数据，也更安全，URL不再被改写。POST发送的数据位于http请求的主体中。一般使用POST来提交表单。</p><h4 id="3、HEAD：接收头部信息"><a href="#3、HEAD：接收头部信息" class="headerlink" title="3、HEAD：接收头部信息"></a>3、HEAD：接收头部信息</h4><p>HEAD和GET很相似，只不过HEAD不接受HTTP响应的内容部分。当你发送了一个HEAD请求，那就意味着你只对HTTP头部感兴趣，而不是文档本身。<br>这个方法可以让浏览器判断页面是否被修改过，从而控制缓存。也可判断所请求的文档是否存在。<br>例如，假如你的网站上有很多链接，那么你就可以简单的给他们分别发送HEAD请求来判断是否存在死链，这比使用GET要快很多。</p><h4 id="4、PUT：-webdav-上传"><a href="#4、PUT：-webdav-上传" class="headerlink" title="4、PUT：(webdav) 上传"></a>4、PUT：(webdav) 上传</h4><h4 id="5、DELETE：-webdav-删除"><a href="#5、DELETE：-webdav-删除" class="headerlink" title="5、DELETE：(webdav) 删除"></a>5、DELETE：(webdav) 删除</h4><h4 id="6、OPTIONS：返回请求的资源所支持的方法的方法"><a href="#6、OPTIONS：返回请求的资源所支持的方法的方法" class="headerlink" title="6、OPTIONS：返回请求的资源所支持的方法的方法"></a>6、OPTIONS：返回请求的资源所支持的方法的方法</h4><h4 id="7、TRACE-追求一个资源请求中间所经过的代理"><a href="#7、TRACE-追求一个资源请求中间所经过的代理" class="headerlink" title="7、TRACE: 追求一个资源请求中间所经过的代理"></a>7、TRACE: 追求一个资源请求中间所经过的代理</h4><h3 id="请求的协议"><a href="#请求的协议" class="headerlink" title="请求的协议"></a>请求的协议</h3><p>http/0.9: stateless<br>http/1.0: MIME, keep-alive (保持连接), 缓存<br>http/1.1: 更多的请求方法，更精细的缓存控制，持久连接(persistent connection) 比较常用</p><h3 id="HTTP请求报文头部信息"><a href="#HTTP请求报文头部信息" class="headerlink" title="HTTP请求报文头部信息"></a>HTTP请求报文头部信息</h3><p>Accept  就是告诉服务器端，我接受那些MIME类型<br>Accept-Encoding  这个看起来是接受那些压缩方式的文件<br>Accept-Lanague   告诉服务器能够发送哪些语言<br>Connection       告诉服务器支持keep-alive特性<br>Cookie           每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端<br>Host             用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多个虚拟主机<br>                 那这里就是用来标识要访问那个虚拟主机。<br>User-Agent       用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等<br>条件请求首部<br>If-Modified-Since 是浏览器向服务器端询问某个资源文件如果自从什么时间修改过，那么重新发给我，这样就保证服务器端资源文件更新时，浏览器再次去请求，而不是使用缓存中的文件<br>安全请求首部：<br>Authorization    客户端提供给服务器的认证信息；<br>MIME 遵循以下格式：major/minor 主类型/次类型 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image/jpg</span><br><span class="line">image/gif</span><br><span class="line">text/html</span><br><span class="line">video/quicktime</span><br><span class="line">appliation/x-httpd-php</span><br></pre></td></tr></table></figure></p><h3 id="HTTP响应头部信息"><a href="#HTTP响应头部信息" class="headerlink" title="HTTP响应头部信息"></a>HTTP响应头部信息</h3><p>Connection            使用keep-alive特性<br>Content-Encoding      使用gzip方式对资源压缩<br>Content-type          MIME类型为html类型，字符集是 UTF-8<br>Date                  响应的日期<br>Server                使用的WEB服务器<br>Transfer-Encoding:chunked   分块传输编码 是http中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（通常是网页浏览器）的数据可以分成多个部分，分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供<br>Vary  这个可以参考（<a href="http://blog.csdn.net/tenfyguo/article/details/5939000）" target="_blank" rel="noopener">http://blog.csdn.net/tenfyguo/article/details/5939000）</a><br>X-Pingback  参考（<a href="http://blog.sina.com.cn/s/blog_bb80041c0101fmfz.html）" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_bb80041c0101fmfz.html）</a></p><h3 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h3><p>1xx: 信息性状态码<br>&emsp;&emsp;100, 101<br>2xx: 成功状态码<br>&emsp;&emsp;200：OK<br>3xx: 重定向状态码<br>&emsp;&emsp;301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;<br>&emsp;&emsp;302: 临时重定向，显式重定向, Location响应首部的值为新的URL<br>&emsp;&emsp;304：Not Modified  未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，告诉浏览器，你不用请求该资源，直接使用本地的资源即可。<br>4xx: 客户端错误状态码<br>&emsp;&emsp;404: Not Found  请求的URL资源并不存在<br>5xx: 服务器端错误状态码<br>&emsp;&emsp;500: Internal Server Error  服务器内部错误<br>&emsp;&emsp;502: Bad Gateway  前面代理服务器联系不到后端的服务器时出现<br>&emsp;&emsp;504：Gateway Timeout  这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看了“&lt;a href=&quot;http://www.linux178.com/web/httprequest.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一次完整的HTTP事务是怎样一个过程？&lt;/a&gt;”这篇博客深有感触，就想做个总结，把对于前端来
      
    
    </summary>
    
      <category term="Web" scheme="http://zhangyi5628.github.io/categories/Web/"/>
    
    
      <category term="HTTP" scheme="http://zhangyi5628.github.io/tags/HTTP/"/>
    
      <category term="TCP" scheme="http://zhangyi5628.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>非常棒的技术博客分享</title>
    <link href="http://zhangyi5628.github.io/2016/05/13/%E9%9D%9E%E5%B8%B8%E6%A3%92%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/"/>
    <id>http://zhangyi5628.github.io/2016/05/13/非常棒的技术博客分享/</id>
    <published>2016-05-13T05:40:44.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享、记录一些我所看过很棒的技术博客  </p><h3 id="1-一次完整的HTTP事务是怎样一个过程？"><a href="#1-一次完整的HTTP事务是怎样一个过程？" class="headerlink" title="1.一次完整的HTTP事务是怎样一个过程？"></a>1.<a href="http://www.linux178.com/web/httprequest.html" target="_blank" rel="noopener">一次完整的HTTP事务是怎样一个过程？</a></h3><h3 id="2-剖析Vue原理-amp-实现双向绑定MVVM？"><a href="#2-剖析Vue原理-amp-实现双向绑定MVVM？" class="headerlink" title="2.剖析Vue原理&amp;实现双向绑定MVVM？"></a>2.<a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">剖析Vue原理&amp;实现双向绑定MVVM？</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分享、记录一些我所看过很棒的技术博客  &lt;/p&gt;
&lt;h3 id=&quot;1-一次完整的HTTP事务是怎样一个过程？&quot;&gt;&lt;a href=&quot;#1-一次完整的HTTP事务是怎样一个过程？&quot; class=&quot;headerlink&quot; title=&quot;1.一次完整的HTTP事务是怎样一个过程？&quot;
      
    
    </summary>
    
      <category term="分享转载" scheme="http://zhangyi5628.github.io/categories/%E5%88%86%E4%BA%AB%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="http://zhangyi5628.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="分享" scheme="http://zhangyi5628.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Array的方法详解一</title>
    <link href="http://zhangyi5628.github.io/2016/05/08/Array%E7%9A%84%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%80/"/>
    <id>http://zhangyi5628.github.io/2016/05/08/Array的方法详解一/</id>
    <published>2016-05-08T08:20:25.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>闲来无事，把js中数组的方法给整理下，发现自己很多方法不常用，容易忘记这些方法具体是做什么的。另外也给自己的博客充实点内容。<br>js中的Array比较奇怪，和java等其他语言相比，js中的数组每一项可以保存任何类型的数据，而且数组的发现是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。数组的length属性也很特别，它不是只读的，因此通过设置length属性，可以做到向数组的末尾移除或添加新元素。<br>js中所有的对象都具有toLocaleString()、toString()、valueOf()三个方法，数组也不例外。</p><h3 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h3><p>1.<a href="#push">push</a><br>2.<a href="#pop">pop</a><br>3.<a href="#shift">shift</a><br>4.<a href="#unshift">unshift</a><br>5.<a href="#reverse">reverse</a><br>6.<a href="#sort">sort</a><br>7.<a href="#concat">concat</a><br>8.<a href="#slice">slice</a><br>9.<a href="#splice">splice</a><br>10.<a href="#join">join</a></p><h3 id="三、详解"><a href="#三、详解" class="headerlink" title="三、详解"></a>三、详解</h3><h4 id="1-Array-push"><a href="#1-Array-push" class="headerlink" title="1.Array.push()"></a><span id="push">1.Array.push()</span></h4><p>js中数组有push()和pop()方法，可以用这两个方法实现类似于栈的行为，即最新添加的最早被移除。栈是一种（Last-In-First-out)后进先出的数据结构。<br>push()方法可以接收任意数量的参数，把它们逐个添加到数组的末尾，并返回添加后的数组长度。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [],</span><br><span class="line">    count = arr.push(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//[1,2]</span></span><br></pre></td></tr></table></figure></p><h4 id="2-Array-pop"><a href="#2-Array-pop" class="headerlink" title="2.Array.pop()"></a><span id="pop">2.Array.pop()</span></h4><p>pop()方法则从数组的末尾移除最后一项元素，减少数组的length值，并返回移除的元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    item = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(item);          <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length);    <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);           <span class="comment">//[1,2]</span></span><br></pre></td></tr></table></figure></p><h4 id="3-Array-shift"><a href="#3-Array-shift" class="headerlink" title="3.Array.shift()"></a><span id="shift">3.Array.shift()</span></h4><p>shift方法可以移除数组中得第一个元素并返回该元素，结合使用shift()和push()就可以想使用队列一样使用数组。栈数据结构的访问规则是后进先出，而队列数据结构的访问规则是先进先出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    item = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(item);          <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length);    <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);           <span class="comment">//[2,3]</span></span><br></pre></td></tr></table></figure></p><h4 id="4-Array-unshift"><a href="#4-Array-unshift" class="headerlink" title="4.Array.unshift()"></a><span id="unshift">4.Array.unshift()</span></h4><p>unshift()方法和shift()的用途正好相反，它能在数组的前端添加任意个元素并返回新数组的长度。和push()方法用法类似，不同点是push是向数组的末尾添加元素。同时使用unshift()和pop()方法，就可以从相反的方向模拟队列，即在数组的前端添加元素，从数组的末尾移除元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    count = arr.unshift(<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);    <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);           <span class="comment">//[-1,0,1,2,3]</span></span><br></pre></td></tr></table></figure></p><h4 id="5-Array-reverse"><a href="#5-Array-reverse" class="headerlink" title="5.Array.reverse()"></a><span id="reverse">5.Array.reverse()</span></h4><p>数组中又两个可以直接用来重排序的方法：reverse()和sort()。reverse()方法为反转数组元素的顺序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//[3, 2, 1]</span></span><br></pre></td></tr></table></figure></p><h4 id="6-Array-sort"><a href="#6-Array-sort" class="headerlink" title="6.Array.sort()"></a><span id="sort">6.Array.sort()</span></h4><p>默认情况下，sort()方法调用每个数组元素的toString()方法来转型，然后比较得到的字符串，按升序排列数组元素。即使数组的每一项都是number类型，sort()方法比较的也是字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//[0,1,10,15,5]</span></span><br></pre></td></tr></table></figure></p><p>sort()方法可以接收一个函数作为参数，函数接收相邻的两个数组元素作为参数。如果第一个参数应该位于第二个参数之前就返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后在返回一个正数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">val1, val2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val1 &lt; val2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val1 &gt; val2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//[15, 10, 5, 1, 0] 倒序</span></span><br></pre></td></tr></table></figure></p><h4 id="7-Array-concat"><a href="#7-Array-concat" class="headerlink" title="7.Array.concat()"></a><span id="concat">7.Array.concat()</span></h4><p>concat()方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。如果没有传参数，就会只返回当前数组的副本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">    arr2 = arr.concat(<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//[1,2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure></p><h4 id="8-Array-slice"><a href="#8-Array-slice" class="headerlink" title="8.Array.slice()"></a><span id="slice">8.Array.slice()</span></h4><p>slice()方法可以基于当前数组中的一个或多个元素创建一个新数组。slice()方法可以接受一或两个参数，即要返回元素的起始和结束位置。当只有一个参数时，slice()方法会返回从该参数指定的位置开始到当前数组末尾所有元素。如果是两个参数，则返回起始和结束位置之前的元素，但不包括结束位置的元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">    arr2 = arr.slice(<span class="number">3</span>),</span><br><span class="line">    arr3 = arr.slice(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">//[4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr3);  <span class="comment">//[4]</span></span><br></pre></td></tr></table></figure></p><p>如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。对于长度是5的数组，slice(-2,-1)与slice(3,4)得到的结果相同。如果结束位置小于起始位置，则返回空数组。</p><h4 id="9-Array-splice"><a href="#9-Array-splice" class="headerlink" title="9.Array.splice()"></a><span id="splice">9.Array.splice()</span></h4><p>splice()方法很强大，它有很多种用法，splice()方法主要用来向数组中部插入元素，使用这个方法的方式有3种。<br>删除：可以删除任意数量的元素，只需指定2个参数：要删除的第一个元素的位置和要删除的元素数量。例如splice(0,2)会删除数组中的前两项。<br>插入：可以向指定位置插入任意数量的元素，需提供3个参数：起始位置，0（要删除的元素数量）和要插入的元素。<br>替换：可以向指定位置插入任意数量的元素，且同事删除任意数量的元素，需要指定3个参数：起始位置，要删除的元素数量和要插入的任意数量的元素。插入的项数不必与删除的项数相等。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">    arr1 = arr.splice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//[3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1);  <span class="comment">//[1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">    arr1 = arr.splice(<span class="number">1</span>, <span class="number">0</span>, [<span class="number">-1</span>,<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//[1, -1, 0, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">    arr1 = arr.splice(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//[0, 0, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p><p>最容易忘记的就是splice()方法，反正我是经常忘记该怎么用这个方法。</p><h4 id="10-Array-join"><a href="#10-Array-join" class="headerlink" title="10.Array.join()"></a><span id="join">10.Array.join()</span></h4><p>join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">'|'</span>));     <span class="comment">//1|2|3</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;闲来无事，把js中数组的方法给整理下，发现自己很多方法不常用，容易忘记这些方法具体是做什么的。另外也给自己的博客充实点内容。
      
    
    </summary>
    
      <category term="javascript" scheme="http://zhangyi5628.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://zhangyi5628.github.io/tags/javascript/"/>
    
      <category term="数组" scheme="http://zhangyi5628.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>javascript-Array的方法详解二（ES5中的Array方法）</title>
    <link href="http://zhangyi5628.github.io/2016/04/22/javascript-Array%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BA%8C%EF%BC%88ES5%E4%B8%AD%E7%9A%84Array%E6%96%B9%E6%B3%95%EF%BC%89/"/>
    <id>http://zhangyi5628.github.io/2016/04/22/javascript-Array方法详解二（ES5中的Array方法）/</id>
    <published>2016-04-22T10:43:17.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>ES5中新增了许多Array的方法，巧用这些方法能够很好的提示代码质量和性能，自己之前也经常忘记这些方法的用法，所以写一写巩固一下。</p><h3 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h3><p>ES5中新增的数组方法如下：<br>1.<a href="#isArray">isArray</a><br>2.<a href="#indexOf">indexOf</a><br>3.<a href="#lastIndexOf">lastIndexOf</a><br>4.<a href="#every">every</a><br>5.<a href="#some">some</a><br>6.<a href="#forEach">forEach</a><br>7.<a href="#map">map</a><br>8.<a href="#filter">filter</a><br>9.<a href="#reduce">reduce</a><br>10.<a href="#reduceRight">reduceRight</a></p><h3 id="三、详解"><a href="#三、详解" class="headerlink" title="三、详解"></a>三、详解</h3><h4 id="1-Array-isArray"><a href="#1-Array-isArray" class="headerlink" title="1.Array.isArray()"></a><span id="isArray">1.Array.isArray()</span></h4><p>判断一个元素是否为数组，不多解释。<br>低版本浏览器可以如下扩展：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray)&#123;</span><br><span class="line">    <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">'[object Array]'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-indexOf"><a href="#2-indexOf" class="headerlink" title="2.indexOf"></a><span id="indexOf">2.indexOf</span></h4><p>和string.indexOf(searchString, position)中的indexOf方法类似。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.indexOf(searchElement[, fromIndex = <span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><p>返回第一个匹配到的元素整数索引，没有匹配到就返回-1（注意使用的时严格匹配模式）。fromIndex可选，表示从这个位置开始匹配，默认值是0。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].indexOf(<span class="string">'2'</span>); <span class="comment">//注意使用的时严格匹配模式</span></span><br><span class="line"><span class="comment">//-1</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].indexOf(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p>兼容处理如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.indexOf) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.indexOf = <span class="function"><span class="keyword">function</span>(<span class="params">searchElement, fromIndex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> k;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'"this" is null or not defined'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = o.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> n = +fromIndex || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(n) === <span class="literal">Infinity</span>) &#123;</span><br><span class="line">      n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= len) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = <span class="built_in">Math</span>.max(n &gt;= <span class="number">0</span> ? n : len - <span class="built_in">Math</span>.abs(n), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> o &amp;&amp; o[k] === searchElement) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">      &#125;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-lastIndexOf"><a href="#3-lastIndexOf" class="headerlink" title="3.lastIndexOf"></a><span id="lastIndexOf">3.lastIndexOf</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.lastIndexOf(searchElement[, fromIndex])</span><br></pre></td></tr></table></figure><p>lastIndexOf和indexOf方法类似，只是lastIndexOf是从数组的末尾开始查询，fromIndex的默认值是array.length - 1.</p><h4 id="4-every"><a href="#4-every" class="headerlink" title="4.every"></a><span id="every">4.every</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.every(callback,[ thisObject]);</span><br></pre></td></tr></table></figure><p>every和some 都是用来测试数组中的项是否满足某一条件。every只有当所有项全部满足时才返回true，some只要有一个满足就返回true。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">10</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><p>兼容写法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.every != <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.every = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> passed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">"function"</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, length = <span class="keyword">this</span>.length; k &lt; length; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (passed === <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">          passed = !!fn.call(context, <span class="keyword">this</span>[k], k, <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> passed;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-some"><a href="#5-some" class="headerlink" title="5.some"></a><span id="some">5.some</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.some(callback,[ thisObject]);</span><br></pre></td></tr></table></figure><p>some是判断数组有没有符合条件的元素，只要有一项满足就返回true，和every正好相反。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].some(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">10</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h4 id="6-forEach"><a href="#6-forEach" class="headerlink" title="6.forEach"></a><span id="forEach">6.forEach</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(callback[, thisArg])</span><br></pre></td></tr></table></figure><p>forEach是循环遍历数组中的每一个元素，等同于for循环。<br>forEach的callback支持3个参数：<br>currentValue：遍历到得当前元素<br>index：对应的数组索引<br>array：数组本身<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>));</span><br><span class="line"><span class="comment">// 1, 0, [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 2, 1, [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 3, 2, [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p><p>forEach不会去遍历数组中空的元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> array[<span class="number">1</span>]; <span class="comment">// 移除 2</span></span><br><span class="line">alert(array); <span class="comment">// "1,,3"</span></span><br><span class="line">alert(array.length); <span class="comment">// but the length is still 3</span></span><br><span class="line">array.forEach(alert); <span class="comment">// 弹出的仅仅是1和3</span></span><br></pre></td></tr></table></figure></p><p>兼容老版浏览器的写法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.forEach != <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, length = <span class="keyword">this</span>.length; k &lt; length; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">"function"</span> &amp;&amp; <span class="built_in">Object</span>.prototype.hasOwnProperty.call(<span class="keyword">this</span>, k)) &#123;</span><br><span class="line">        fn.call(context, <span class="keyword">this</span>[k], k, <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7-map"><a href="#7-map" class="headerlink" title="7.map"></a><span id="map">7.map</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.map(callback[, thisArg])</span><br></pre></td></tr></table></figure><p>map是指通过callback方法把原数组“映射”成对应的新数组，用法和forEach类似。<br>callback同样支持三个参数：<br>currentValue：遍历到得当前元素<br>index：对应的数组索引<br>array：数组本身<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;<span class="keyword">return</span> item*<span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"><span class="comment">//[2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;item*<span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br><span class="line"><span class="comment">//[undefined, undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure></p><p>callback中如果return，就会返回undefined。<br>兼容老版浏览器的写法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.map != <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, length = <span class="keyword">this</span>.length; k &lt; length; k++) &#123;      </span><br><span class="line">         arr.push(fn.call(context, <span class="keyword">this</span>[k], k, <span class="keyword">this</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="8-filter"><a href="#8-filter" class="headerlink" title="8.filter"></a><span id="filter">8.filter</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.filter(callback[, thisArg])</span><br></pre></td></tr></table></figure><p>filter为“过滤”、“筛选”之意。指数组filter后，返回过滤后的新数组。<br>filter的callback函数需要返回布尔值true或false. 如果为true则表示通过添加到新数组中，如果是false这不通过。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arrayFilter = data.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arrayFilter);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p><p>返回值只要是弱等于== true/false就可以了，而非非得返回 === true/false<br>兼容老版浏览器的写法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.filter) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.filter = <span class="function"><span class="keyword">function</span>(<span class="params">fun<span class="regexp">/*, thisArg*/</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="keyword">void</span> <span class="number">0</span> || <span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> len = t.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fun !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> thisArg = <span class="built_in">arguments</span>.length &gt;= <span class="number">2</span> ? <span class="built_in">arguments</span>[<span class="number">1</span>] : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> t) &#123;</span><br><span class="line">        <span class="keyword">var</span> val = t[i];</span><br><span class="line">        <span class="keyword">if</span> (fun.call(thisArg, val, i, t)) &#123;</span><br><span class="line">          res.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="9-reduce"><a href="#9-reduce" class="headerlink" title="9.reduce"></a><span id="reduce">9.reduce</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.reduce(callback[, initialValue])</span><br></pre></td></tr></table></figure><p>reduce中callback函数接受4个参数：之前值(上一次的处理结果 - 通过上一次调用回调函数获得的值)、当前值、索引值以及数组本身。initialValue参数可选，表示初始值。若指定，则当作最初使用的previous值；如果缺省，则使用数组的第一个元素作为previous初始值，同时current往后排一位，相比有initialValue值少一次迭代。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">previous, current, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> previous + current;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><p>有了reduce，我们可以轻松实现二维数组的扁平化：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组扁平化</span></span><br><span class="line"><span class="keyword">var</span> flatten = matrix.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">previous, current</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> previous.concat(current);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></p><h4 id="10-reduceRight"><a href="#10-reduceRight" class="headerlink" title="10.reduceRight"></a><span id="reduceRight">10.reduceRight</span></h4><p>reduceRight跟reduce相比，用法类似：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.reduceRight(callback[, initialValue])</span><br></pre></td></tr></table></figure></p><p>实现上差异在于reduceRight是从数组的末尾开始实现。看下面这个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> specialDiff = data.reduceRight(<span class="function"><span class="keyword">function</span> (<span class="params">previous, current, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> previous + current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> previous - current;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(specialDiff); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;ES5中新增了许多Array的方法，巧用这些方法能够很好的提示代码质量和性能，自己之前也经常忘记这些方法的用法，所以写一写巩
      
    
    </summary>
    
      <category term="javascript" scheme="http://zhangyi5628.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://zhangyi5628.github.io/tags/javascript/"/>
    
      <category term="数组" scheme="http://zhangyi5628.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>最近面试遇到的一些js笔试题</title>
    <link href="http://zhangyi5628.github.io/2016/04/06/%E6%9C%80%E8%BF%91%E9%9D%A2%E8%AF%95%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9Bjs%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://zhangyi5628.github.io/2016/04/06/最近面试遇到的一些js笔试题/</id>
    <published>2016-04-06T10:28:10.000Z</published>
    <updated>2017-11-19T01:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、随机给出一个字符串，例如：adadfdfseffserfefsefsee，找出出现次数最多的字母。"><a href="#1、随机给出一个字符串，例如：adadfdfseffserfefsefsee，找出出现次数最多的字母。" class="headerlink" title="1、随机给出一个字符串，例如：adadfdfseffserfefsefsee，找出出现次数最多的字母。"></a>1、随机给出一个字符串，例如：adadfdfseffserfefsefsee，找出出现次数最多的字母。</h4><p>这道题有两种做法，<br>第一种方法是创建一个object，循环字符以字符为object的key，初始的value为1，循环的过程中，遇到同样的字符，就+1，最后得到的时类似于这样的对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    b:<span class="number">10</span>,</span><br><span class="line">    c: <span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在对这个对象的每个key和value做排序。当然这种方法不好，要做几遍循环，比较消耗性能。  </p><p>第二种方法是循环字符，把字符串中相同的字母都替换为空，再用本次循环中最初的字符串长度减去替换后的字符串长度，就得到了本次循环的字符在字符串中的总数，而且每次循环都会吧相同的字符替换为空，循环需要的次数越来越少，能提高性能。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str =<span class="string">"adadfdfseffserfefsefseeffffftsdg"</span>; <span class="comment">//命名一个变量放置给出的字符串</span></span><br><span class="line"><span class="keyword">var</span> maxLength = <span class="number">0</span>; <span class="comment">//命名一个变量放置字母出现的最高次数并初始化为0</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">''</span>; <span class="comment">//命名一个变量放置结果输入  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( str != <span class="string">''</span> )&#123; <span class="comment">//循环迭代开始，并判断字符串是否为空</span></span><br><span class="line">    oldStr = str; <span class="comment">//将原始的字符串变量赋值给新变量</span></span><br><span class="line">    getStr = str.substr(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//用字符串的substr的方法得到第一个字符（首字母）</span></span><br><span class="line">    str = str.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(getStr, <span class="string">"g"</span>), <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( oldStr.length-str.length &gt; maxLength ) &#123; <span class="comment">//判断原始的字符串的长度减去替代后字符串长度是否大于之前出现的最大的字符串长度</span></span><br><span class="line">        maxLength = oldStr.length-str.length; <span class="comment">//两字符串长度相减得到最大的字符串长度</span></span><br><span class="line">        result = getStr + <span class="string">"="</span> + maxLength <span class="comment">//返回最大的字符串结果（字母、出现次数）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">alert(result) <span class="comment">//弹出结果</span></span><br></pre></td></tr></table></figure></p><h4 id="2、写出以下代码的输出结果："><a href="#2、写出以下代码的输出结果：" class="headerlink" title="2、写出以下代码的输出结果："></a>2、写出以下代码的输出结果：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setTimeout是异步的，所以setTimeout会在循环过后执行，此时i为5，所以会输出5遍5。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、随机给出一个字符串，例如：adadfdfseffserfefsefsee，找出出现次数最多的字母。&quot;&gt;&lt;a href=&quot;#1、随机给出一个字符串，例如：adadfdfseffserfefsefsee，找出出现次数最多的字母。&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="javascript" scheme="http://zhangyi5628.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://zhangyi5628.github.io/tags/javascript/"/>
    
      <category term="笔试题" scheme="http://zhangyi5628.github.io/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
